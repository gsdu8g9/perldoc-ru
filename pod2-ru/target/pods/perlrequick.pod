=encoding UTF-8
=head1 НАЗВАНИЕ

perlrequick - быстрый старт использования регулярных выражений Perl

=head1 ОПИСАНИЕ

Эта страница описывает самые простые шаги для понимания, создания и использования регулярных выражений ('регексов' от regex, сокр. от regular expression) в Perl.


=head1 Руководство

=head2 Простой поиск соответствия слова

Простейший регекс это просто слово, или, более обще, строка символов.
Регекс, состоящий из слова, соответствует любой строке, содержащей это слово:

    "Hello World" =~ /World/;  # совпадение

В этом выражении, C<World> это регекс и слеши C<//> вокруг
C</World/> говорят Perl искать строку для совпадения.  Оператор
C<=~> связывает строку с регексом и выдает значение true
если регекс совпадает, или false если нет.  В нашем случае, C<World> совпадает со вторым словом в C<"Hello World">, таким образом выражение истинно. У этой идеи есть несколько вариаций.

Такие выражения полезны в условиях:

    print "Найдено\n" if "Hello World" =~ /World/;

Смысл совпадения может быть полностью изменен при помощи оператора C<!~>:

    print "Не совпало\n" if "Hello World" !~ /World/;

Последовательность строк в регексе может быть заменена переменной:

    $greeting = "World";
    print "Найдено\n" if "Hello World" =~ /$greeting/;

Если вы ищите в C<$_>, то эту часть C<$_ =~> можно опустить: 

    $_ = "Hello World";
    print "Найдено\n" if /World/;

Наконец, разделители по умолчанию C<//> для поиска могут быть изменены на
произвольные разделители, но тогда в начале должны быть буква C<'m'>:

    "Hello World" =~ m!World!;   # найдено, разделители '!'
    "Hello World" =~ m{World};   # найдено, отметим совпадение '{}'
    "/usr/bin/perl" =~ m"/perl"; # найдено после '/usr/bin',
                                 # '/' стал произвольным символом

Регексы должны I<точно> совпадать с частью строки чтобы выражение было true:

    "Hello World" =~ /world/;  # не совпадает, с учетом регистра
    "Hello World" =~ /o W/;    # найдено, ' ' здесь обычный символ
    "Hello World" =~ /World /; # не совпадает, нет ' ' в конце

Perl будет всегда находить самое первое совпадение в строке:

    "Hello World" =~ /o/;       # найдет 'o' в 'Hello'
    "That hat is red" =~ /hat/; # найдет 'hat' в 'That'

Не все символы могут использоваться, 'как есть' в поиске. Некоторые, называемые B<метасимволами>,
 зарезервированы как специальные символы в регекс.
Метасимволы это

    {}[]()^$.|*+?\

Метасимвол может быть найден, если перед ним поставить обратный слеш:

    "2+2=4" =~ /2+2/;    # не найдет, т.к. + это метасимвол
    "2+2=4" =~ /2\+2/;   # найдено, \+ считается обычным знаком +
    'C:\WIN32' =~ /C:\\WIN/;                       # найдено
    "/usr/bin/perl" =~ /\/usr\/bin\/perl/;  # найдено

В последнем регексе перед первым слешем C<'/'> также ставиться бэкслеш,
потому что слеш здесь используется, чтобы разграничить регекс.

Непечатные символы ASCII представлены B<управляющими последовательностями>.
Типичными примерами являются  C<\t> для символа табуляции, C<\n> для символа перехода на новую строку, и C<\r>
для возврата каретки. Произвольные байты представлены восьмеричными
управляющими последовательностями, например, C<\033>, или шестнадцатеричными управляющими последовательностями,
например, C<\x1B>:

    "1000\t2000" =~ m(0\t2)      # найдено
    "cat"      =~ /\143\x61\x74/ # найдено в кодах ASCII, хотя и странный способ искать cat

Регексы рассматриваются в основном как строки в двойных кавычках, поэтому работает интерполяция переменной:    

    $foo = 'house';
    'cathouse' =~ /cat$foo/;   # найдено
    'housecat' =~ /${foo}cat/; # найдено

Со всеми регексами выше, если регекс находит соответствие в любой точке
строки, то он считается найденным. Чтобы указать I<где> он должен
быть найден, мы будем использовать B<якорем> метасимволы C<^> и C<$>.
Якорь C<^> означает поиск в начале строки , а якорь
C<$> означает поиск в конце строки или перед символом перевода строки в
конце строки. Несколько примеров:

    "housekeeper" =~ /keeper/;         # найдено
    "housekeeper" =~ /^keeper/;        # не найдено
    "housekeeper" =~ /keeper$/;        # найдено
    "housekeeper\n" =~ /keeper$/;      # найдено
    "housekeeper" =~ /^housekeeper$/;  # найдено

=head2 Использование классов символов

B<Класс символов> позволяет набору возможных символов, а не только одному символу,
соответствовать в определенной точке в регексе.
Класс символом обозначается квадратными скобками C<[...]>, с набором символов, которые нужно найти внутри.
Вот некоторые примеры:

    /cat/;            # найдет 'cat'
    /[bcr]at/;        # найдет 'bat', 'cat', or 'rat'
    "abc" =~ /[cab]/; # найдет 'a'

В последнем вырадении, даже несмотря на то, что C<'c'> является первым символом в классе, 
самой ранней точкой совпадения регекса будет C<'a'>.

    /[yY][eE][sS]/; # найдет 'yes' в регистронезависимом поиске
                    # 'yes', 'Yes', 'YES', etc.
    /yes/i;         # также найдет 'yes' без учета регистра

Последний пример показывает поиск с B<модификатором> C<'i'> , который делает
поиск независимым от регистра (ignore registr).

Классы символов также имеют обычные и специальные символы, но
наборы обычных и специальных символов внутри класса символов
отличаются от тех, которые есть за пределами класса символов. Спец
символами для классов символов являются C<-]\^$> и для их поиска
используется экранирование символом escape:

   /[\]c]def/; # найдет ']def' или 'cdef'
   $x = 'bcr';
   /[$x]at/;   # найдет 'bat, 'cat', или 'rat'
   /[\$x]at/;  # найдет '$at' или 'xat'
   /[\\$x]at/; # найдет '\at', 'bat, 'cat', или 'rat'

Особый символ C<'-'> действует как оператор диапазона с классе символов, 
так что громоздкая запись C<[0123456789]> и C<[abc...xyz]>
становится стройной C<[0-9]> и C<[a-z]>:

    /item[0-9]/;  # найдет 'item0' или ... или 'item9'
    /[0-9a-fA-F]/;  # найдет шестнадцатиричные цифры

If C<'-'> is the first or last character in a character class, it is
treated as an ordinary character.

The special character C<^> in the first position of a character class
denotes a B<negated character class>, which matches any character but
those in the brackets.  Both C<[...]> and C<[^...]> must match a
character, or the match fails.  Then

    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary

Perl has several abbreviations for common character classes. (These
definitions are those that Perl uses in ASCII-safe mode with the C</a> modifier.
Otherwise they could match many more non-ASCII Unicode characters as
well.  See L<perlrecharclass/Backslash sequences> for details.)

=over 4

=item *

\d is a digit and represents

    [0-9]

=item *

\s is a whitespace character and represents

    [\ \t\r\n\f]

=item *

\w is a word character (alphanumeric or _) and represents

    [0-9a-zA-Z_]

=item *

\D is a negated \d; it represents any character but a digit

    [^0-9]

=item *

\S is a negated \s; it represents any non-whitespace character

    [^\s]

=item *

\W is a negated \w; it represents any non-word character

    [^\w]

=item *

The period '.' matches any character but "\n"

=back

The C<\d\s\w\D\S\W> abbreviations can be used both inside and outside
of character classes.  Here are some in use:

    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'

The S<B<word anchor> > C<\b> matches a boundary between a word
character and a non-word character C<\w\W> or C<\W\w>:

    $x = "Housecat catenates house and cat";
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string

In the last example, the end of the string is considered a word
boundary.

=head2 Matching this or that

We can match different character strings with the B<alternation>
metacharacter C<'|'>.  To match C<dog> or C<cat>, we form the regex
C<dog|cat>.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, C<dog>.  If
C<dog> doesn't match, Perl will then try the next alternative, C<cat>.
If C<cat> doesn't match either, then the match fails and Perl moves to
the next position in the string.  Some examples:

    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"

Even though C<dog> is the first alternative in the second regex,
C<cat> is able to match earlier in the string.

    "cats"          =~ /c|ca|cat|cats/; # matches "c"
    "cats"          =~ /cats|cat|ca|c/; # matches "cats"

At a given character position, the first alternative that allows the
regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.

=head2 Grouping things and hierarchical matching

The B<grouping> metacharacters C<()> allow a part of a regex to be
treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex C<house(cat|keeper)> means match
C<house> followed by either C<cat> or C<keeper>.  Some more examples
are

    /(a|b)b/;    # matches 'ab' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere

    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.

    "20" =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match

=head2 Extracting matches

The grouping metacharacters C<()> also allow the extraction of the
parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables C<$1>, C<$2>, etc.
They can be used just as ordinary variables:

    # extract hours, minutes, seconds
    $time =~ /(\d\d):(\d\d):(\d\d)/;  # match hh:mm:ss format
    $hours = $1;
    $minutes = $2;
    $seconds = $3;

In list context, a match C</regex/> with groupings will return the
list of matched values C<($1,$2,...)>.  So we could rewrite it as

    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);

If the groupings in a regex are nested, C<$1> gets the group with the
leftmost opening parenthesis, C<$2> the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:

    /(ab(cd|ef)((gi)|j))/;
     1  2      34

Associated with the matching variables C<$1>, C<$2>, ... are
the B<backreferences> C<\g1>, C<\g2>, ...  Backreferences are
matching variables that can be used I<inside> a regex:

    /(\w\w\w)\s\g1/; # find sequences like 'the the' in string

C<$1>, C<$2>, ... should only be used outside of a regex, and C<\g1>,
C<\g2>, ... only inside a regex.

=head2 Matching repetitions

The B<quantifier> metacharacters C<?>, C<*>, C<+>, and C<{}> allow us
to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:

=over 4

=item *

C<a?> = match 'a' 1 or 0 times

=item *

C<a*> = match 'a' 0 or more times, i.e., any number of times

=item *

C<a+> = match 'a' 1 or more times, i.e., at least once

=item *

C<a{n,m}> = match at least C<n> times, but not more than C<m>
times.

=item *

C<a{n,}> = match at least C<n> or more times

=item *

C<a{n}> = match exactly C<n> times

=back

Here are some examples:

    /[a-z]+\s+\d*/;  # match a lowercase word, at least some space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/;    # better match; throw out 3 digit dates

These quantifiers will try to match as much of the string as possible,
while still allowing the regex to match.  So we have

    $x = 'the cat in the hat';
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)

The first quantifier C<.*> grabs as much of the string as possible
while still having the regex match. The second quantifier C<.*> has
no string left to it, so it matches 0 times.

=head2 More matching

There are a few more things you might want to know about matching
operators.
The global modifier C<//g> allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have C<//g> jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the C<pos()> function.
For example,

    $x = "cat dog house"; # 3 words
    while ($x =~ /(\w+)/g) {
        print "Word is $1, ends at position ", pos $x, "\n";
    }

prints

    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13

A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
C<//c>, as in C</regex/gc>.

In list context, C<//g> returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regex.  So

    @words = ($x =~ /(\w+)/g);  # matches,
                                # $word[0] = 'cat'
                                # $word[1] = 'dog'
                                # $word[2] = 'house'

=head2 Search and replace

Search and replace is performed using C<s/regex/replacement/modifiers>.
The C<replacement> is a Perl double-quoted string that replaces in the
string whatever is matched with the C<regex>.  The operator C<=~> is
also used here to associate a string with C<s///>.  If matching
against C<$_>, the S<C<$_ =~>> can be dropped.  If there is a match,
C<s///> returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:

    $x = "Time to feed the cat!";
    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
    $y = "'quoted words'";
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains "quoted words"

With the C<s///> operator, the matched variables C<$1>, C<$2>, etc.
are immediately available for use in the replacement expression. With
the global modifier, C<s///g> will search and replace all occurrences
of the regex in the string:

    $x = "I batted 4 for 4";
    $x =~ s/4/four/;   # $x contains "I batted four for 4"
    $x = "I batted 4 for 4";
    $x =~ s/4/four/g;  # $x contains "I batted four for four"

The non-destructive modifier C<s///r> causes the result of the substitution
to be returned instead of modifying C<$_> (or whatever variable the
substitute was bound to with C<=~>):

    $x = "I like dogs.";
    $y = $x =~ s/dogs/cats/r;
    print "$x $y\n"; # prints "I like dogs. I like cats."

    $x = "Cats are great.";
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\n";
    # prints "Hedgehogs are great."

    @foo = map { s/[a-z]/X/r } qw(a b c 1 2 3);
    # @foo is now qw(X X X 1 2 3)

The evaluation modifier C<s///e> wraps an C<eval{...}> around the
replacement string and the evaluated result is substituted for the
matched substring.  Some examples:

    # reverse all the words in a string
    $x = "the cat in the hat";
    $x =~ s/(\w+)/reverse $1/ge;   # $x contains "eht tac ni eht tah"

    # convert percentage to decimal
    $x = "A 39% hit rate";
    $x =~ s!(\d+)%!$1/100!e;       # $x contains "A 0.39 hit rate"

The last example shows that C<s///> can use other delimiters, such as
C<s!!!> and C<s{}{}>, and even C<s{}//>.  If single quotes are used
C<s'''>, then the regex and replacement are treated as single-quoted
strings.

=head2 The split operator

C<split /regex/, string> splits C<string> into a list of substrings
and returns that list.  The regex determines the character sequence
that C<string> is split with respect to.  For example, to split a
string into words, use

    $x = "Calvin and Hobbes";
    @word = split /\s+/, $x;  # $word[0] = 'Calvin'
                              # $word[1] = 'and'
                              # $word[2] = 'Hobbes'

To extract a comma-delimited list of numbers, use

    $x = "1.618,2.718,   3.142";
    @const = split /,\s*/, $x;  # $const[0] = '1.618'
                                # $const[1] = '2.718'
                                # $const[2] = '3.142'

If the empty regex C<//> is used, the string is split into individual
characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:

    $x = "/usr/bin";
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'

Since the first character of $x matched the regex, C<split> prepended
an empty initial element to the list.

=head1 BUGS

None.

=head1 SEE ALSO

This is just a quick start guide.  For a more in-depth tutorial on
regexes, see L<perlretut> and for the reference page, see L<perlre>.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 2000 Mark Kvale
All rights reserved.

This document may be distributed under the same terms as Perl itself.

=head2 Acknowledgments

The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.

=cut

