=encoding utf8

=head1 НАИМЕНОВАНИЕ

perlretut - учебник регулярных выражений Perl

=head1 ОПИСАНИЕ

Этот документ является базовым учебником по пониманию, созданию и
использованию регулярных выражений в Perl. Он служит в качестве дополнения к
справочной странице о регулярных выражениях L<perlre>. Регулярные выражения
являются неотъемлемой частью операторов C<m//>, C<s///>, C<qr//> и C<split>
, также этот учебник пересекается со страницами
L<perlop/"Регексп операторы заключения в кавычки"> и L<perlfunc/split>.

Perl широко известен за свои выдающиеся возможности по обработке текста, и регулярные 
выражения являются одним из китов, стоящих за этой славой. Регулярные 
выражения Perl показывают эффективность и гибкость, неизвестную в большинстве
других компьютерных языков. Освоение даже азов регулярных 
выражений позволит вам манипулировать текстом с удивительной легкостью.

Что такое регулярное выражение? Регулярное выражение это просто строка 
, которая описывает образец или шаблон, который мы должны найти. Шаблон поиска используются теперь повсеместно; 
примерами являются шаблоны, которые вводятся в поисковую систему для поиска веб-страниц
и шаблоны, используемые для получения списка файлов в директории, например, C<ls *.txt>
или  C<dir *.*>. В Perl, шаблоны, описанные регулярными выражениями,
используются для поиска строк, извлечения нужных частей строк, и для 
 операций поиска и замены.

Регулярные выражения имеют незаслуженную репутацию абстрактных
и трудно понимаемых. Регулярные выражения создаются с помощью
простых понятий, таких как условия и циклы и их не сложнее понять,
чем соответствующие условные операторы  C<if> и циклы C<while>
 в самом языке Perl.  Фактически, главная проблема в 
 изучении регулярных выражений, это просто привыкнуть к кратким
обозначениям, которые используются для выражения этих понятий.

Этот учебник сглаживает кривую обучения, обсуждая концепцию регулярных
 выражений, а также их обозначения на множестве примеров. 
 Если вы овладеете первой частью, то будете иметь все инструменты, необходимые для решения
около 98% ваших потребностей. Вторая часть урока для тех, кто 
знаком с основами и голоден для более мощных инструментов. Там
рассматриваются более продвинутые операторы регулярных выражений и
представляют последние передовые инновации.

Примечание: чтобы сэкономить время, 'регулярное выражение' часто сокращают
 как регексп или регекс. Регексп - более естественная аббревиатура, чем регекс, но 
труднее произносится. В документации Perl pod равномерно распределяются сокращения
Регексп и Регекс; в Perl существует более одного способа сокращать его.(there is more than one way to abbreviate it!)
В этом руководстве мы будем использовать регексп.

=head1 Часть 1: Основы

=head2 Простой поиск слова

Простейший регексп это просто слово, или, более обще, строка символов.
Регексп, состоящий из слова, соответствует любой строке, содержащей это слово:

    "Hello World" =~ /World/;  # совпадение

О чём это выражение? C<"Hello World"> - это проста строка, заключённая 
в двойные кавычки.  C<World> - это это регулярное выражение и
заключеное в C<//> слово C</World/> говорит Perl искать вхождение строки.
Оператор C<=~> связывает строку с регекспом и выдает значение true
если регексп совпадает, или false если нет.
 В нашем случае, C<World> совпадает со вторым словом в C<"Hello World">, 
 таким образом выражение истинно. У этой идеи есть несколько вариаций.  Такие выражения
полезны в условных операторах:

    if ("Hello World" =~ /World/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Есть много полезных вариантов на эту тему.
Смысл совпадения может быть полностью изменен при помощи оператора C<!~>:

    if ("Hello World" !~ /World/) {
        print "Не Найдено\n";
    }
    else {
        print "Найдено\n";
    }

Последовательность строк в регексе может быть заменена переменной:

    $greeting = "World";
    if ("Hello World" =~ /$greeting/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Если вы ищите в специальной переменной по умолчанию C<$_>, 
то эту часть C<$_ =~> можно опустить:

    $_ = "Hello World";
    if (/World/) {
        print "Найдено\n";
    }
    else {
        print "Не Найдено\n";
    }

Наконец, разделители по умолчанию C<//> для поиска могут быть изменены на
произвольные разделители, но тогда в начале должны быть буква C<'m'>:

    "Hello World" =~ m!World!;   # найдено, разделители '!'
    "Hello World" =~ m{World};   # найдено, отметим совпадение '{}'
    "/usr/bin/perl" =~ m"/perl"; # найдено после '/usr/bin',
                                 # '/' стал произвольным символом

C</World/>, C<m!World!> и C<m{World}> все представляют собой то же самое. 
Например, когда кавычки (C<">) используются в качестве разделителя, то косая черта
C<'/'>  становится обычным символом и может быть использован в этом регекспе
без проблем.
Давайте рассмотрим, каким образом различные регекспы будет соответствовать 
 C<"Hello World">:

    "Hello World" =~ /world/;  # не найдено
    "Hello World" =~ /o W/;    # найдено
    "Hello World" =~ /oW/;     # не найдено
    "Hello World" =~ /World /; # не найдено

Первый регексп C<world> не совпадает, потому регексп 
учитывает регистр. Второй регексп совпадает потому что подстрока
S<C<'o W'>> встречается в строке S<C<"Hello World">>. Пробельный
 символ ' ' рассматривается как любой другой символ в регекспе и будет 
 найден в этом случае. Отсутствие пробела
 является причиной того, почему третий регексп C<'oW'> не совпадает. Четвертый 
 регексп C<'World '> не совпадает, потому что есть пробел в конце
регекспа, но не в конце строки. Урок здесь состоит в том, что
регекспы должны I<точно> совпадать с частью строки для того,
 чтобы выражение стало истинным.

Если регексп находится больше одного раза в строке, 
Perl будет всегда находить самое первое совпадение в строке:

    "Hello World" =~ /o/;       # найдет 'o' в 'Hello'
    "That hat is red" =~ /hat/; # найдет 'hat' в 'That'

Что касается соответствия символов есть еще несколько пунктов, которые нужно знать.
Во-первых, не все символы могут использоваться, 'как есть' в поиске. Некоторые, называемые B<метасимволами>,
 зарезервированы для использования в описании регекса.
Метасимволы это

    {}[]()^$.|*+?\

Значение каждого из них будет объяснено
в остальной части учебника, но на данный момент, важно только знать
то, что метасимвол может быть найден, если перед ним поставить 
обратную косую черту:

    "2+2=4" =~ /2+2/;    # не найдет, т.к. + это метасимвол
    "2+2=4" =~ /2\+2/;   # найдено, \+ считается обычным знаком +
    "The interval is [0,1)." =~ /[0,1)./     # будет синтаксическая ошибка!
    "The interval is [0,1)." =~ /\[0,1\)\./  # найдет
    "#!/usr/bin/perl" =~ /#!\/usr\/bin\/perl/;  # найдет

В последнем регекспе перед первой косой чертой C<'/'> также ставиться обратная косая черта,
потому что косая черта здесь используется, чтобы разграничить регексп.
Это может привести к СВЗ
(синдрому выступающей зубочистки), однако, выражение можно сделать более читаемым, если
 изменить разделители.

    "#!/usr/bin/perl" =~ m!#\!/usr/bin/perl!;  # читается легче

Символ обратной косой черты C<'\'> является метасимволом и для его поиска нужна еще
одна косая черта:

    'C:\WIN32' =~ /C:\\WIN/;   # найдет

В добавлении к метасимволам, есть некоторые символы ASCII 
которые не имеют печатных аналогов и вместо этого
представлены B<escape-последовательностями>.
Типичными примерами являются  C<\t> для табуляции, C<\n> для символа перехода на новую строку, C<\r>
для возврата каретки и C<\a> для пищалки (или сигнала предупреждения). 
Если о строке думать как о последовательности произвольных байт, то
восьмеричные escape-последовательности, например, C<\033>, или шестнадцатеричные escape-последовательности,
например, C<\x1B> могут быть более естественным представлением для ваших байт.
Вот несколько примеров escape-последовательностей:

    "1000\t2000" =~ m(0\t2)   # найдет
    "1000\n2000" =~ /0\n20/   # найдет
    "1000\t2000" =~ /\000\t2/ # не найдет, "0" не равен "\000"
    "cat"   =~ /\o{143}\x61\x74/ # найдено в кодах ASCII, хотя и странный способ
                                 # искать cat

Если вы уже использовали Perl какое-то время, все эти разговоры об escape-последовательностях
могут показаться знакомыми. Подобные escape-последовательности
 используются в двойных кавычках и фактически регекспы в Perl в основном рассматриваются как
строки в двойных кавычках. Это означает, что переменные также могут использоваться в регекспах.
Подобно строкам в двойных кавычках, значение
переменной в регекспе будет подставлено прежде чем регексп выполнит поиск. 
Итак, мы имеем:                                 

    $foo = 'house';
    'housecat' =~ /$foo/;      # найдено
    'cathouse' =~ /cat$foo/;   # найдено
    'housecat' =~ /${foo}cat/; # найдено

Пока все в порядке. Со знаниями, полученными выше вы можете уже выполнять
поиски регекспом почти любой символьной строки , о которой можно мечтать.
Вот I<очень простая> эмуляция программы grep Unix:

    % cat > simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (<>) {
        print if /$regexp/;
    }
    ^D

    % chmod +x simple_grep

    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards

Эту программу легко понять.  C<#!/usr/bin/perl> это стандартный 
способ вызвать программу Perl из командной строки.
S<C<$regexp = shift;>> сохраняет первый аргумент командной строки, как
регексп, который будет использоваться, а оставшиеся аргументы командной строки
рассматриваются как файлы. S<C<< while (<>) >>> перебирает все строки во всех входящих
файлах.  Для каждой строки, S<C<print if /$regexp/;>> напечатает строку, если
 регексп будет в ней найден.  В этой строке, оба оператора C<print> и
C</$regexp/> используют переменную по умолчанию C<$_> неявно.

Во всех регекспах выше, если регексп находит соответствие в любой точке строки,
то он считается найденным. Иногда однако, мы хотели бы
указать I<где> в строке регексп должен искать.
Чтобы указать где он должен быть найден, 
мы будем использовать I<якорем> метасимволы C<^> и C<$>. 
Якорь C<^> означает поиск в начале строки , а якорь C<$> означает поиск 
в конце строки или перед символом перевода строки в конце строки. 
Вот как они используются:

    "housekeeper" =~ /keeper/;    # найдено
    "housekeeper" =~ /^keeper/;   # не найдено
    "housekeeper" =~ /keeper$/;   # найдено
    "housekeeper\n" =~ /keeper$/; # найдено

Второй регексп не найдет, т.к. C<^> вынуждает, чтобы C<keeper> 
 искался только в начале строки, но C<"housekeeper"> содержит
keeper начинающийся посередине.  Третий регексп найдет, т.к. 
C<$> принуждает C<keeper> искаться только в конце строки.

Когда одновременно используются и C<^> и C<$> , то регексп 
должен найти и начало и конец строки, таким образом регексп должен
 найти всю строку целиком (совпасть).  

    "keeper" =~ /^keep$/;      # не найдет
    "keeper" =~ /^keeper$/;    # найдет
    ""       =~ /^$/;          # ^$ находит пустую строку

Первый регексп не совпадает, потому что длинее, чем C<keep>.
Поскольку второй регексп совпадает со строкой, то он ее найдет. 
Использование C<^> и C<$> в regexp принуждает к поиску всей строки,
таким образом это дает вам полный контроль над тем, какие строки
 искать, а какие нет. Предположим, что вы ищете парня по имени
bert,  находящегося целиком в строке:

    "dogbert" =~ /bert/;   # найдет, но не то, что хотим

    "dilbert" =~ /^bert/;  # не найдет, но ..
    "bertram" =~ /^bert/;  # найдет, но пока еще не так хорошо

    "bertram" =~ /^bert$/; # не найдет, хорошо
    "dilbert" =~ /^bert$/; # не найдет, хорошо
    "bert"    =~ /^bert$/; # найдет, идеально

Конечно, в случае со строковой константой, ее можно было бы найти
гораздо проще просто использовав сравнение строк  S<C<$string eq 'bert'>> и это было бы
более эффективным. Regexp C<^...$> действительно становится полезным, когда мы
добавляем более мощные конструкции в regexp.

=head2 Использование классов символов

Хотя можно сделать очень много уже со строковыми коснтантами
в виде регекспов выше, мы только прикоснулись к технологии регулярных выражений. 
В этом и последующих разделах мы будем вводить regexp
концепции (и связанные с ними описания метасимволов), что позволит
регексп представлять не только, как последовательность одного символа, но и 
I<целого класса> символов.

Одна из таких концепций это I<классы символов>. Класс символов
позволяет созадать набор возможных символов, а не только одного, 
чтобы соответствовать определенной точке регекспа. Классы символов
обозначаются квадратными скобками <[...]>, с набором возможных 
для сопоставления символов внутри. Вот несколько примеров:

    /cat/;       # найдет 'cat'
    /[bcr]at/;   # найдет 'bat, 'cat', или 'rat'
    /item[0123456789]/;  # найдет 'item0' или ... или 'item9'
    "abc" =~ /[cab]/;    # найдет 'a'

В последнем выражении, даже несмотря на то, что C<'c'> является первым символом в классе, 
самой ранней точкой совпадения регекспа будет C<'a'>.

    /[yY][eE][sS]/;      # найдет 'yes' в регистронезависимом поиске
                         # 'yes', 'Yes', 'YES', etc.

Последний пример показывает обычную задачу: сделать регистронезависимый поиск.
Perl предоставляет путь, чтобы исключить все эти скобки, просто добавив
C<'i'> в конце поисковой строки. Тогда C</[yY][eE][sS]/;>
можно переписать как C</yes/i;>, где C<'i'> означает
без учета регистра и является примером I<модификатора> 
операции поиска. Мы встретим другие модификаторы в этом руководстве позднее.

Мы видели выше в разделе, что там были обычные символы, которые
представляли сами себя и специальные символы, которым необходима
обратная косая черта  C<\> в начале, чтобы представлять себя. То же самое верно в
классах символов, но наборы обычных и специальных символов
внутри класса символов отличаются от тех, которые есть за его пределами. 
Специальными символами для класса символов являются  C<-]\^$>  (и
разделитель шаблона , каким бы он ни был).
C<]>  - специальный, потому что оно обозначает конец класса символов. C<$>
 - специальный, потому что он обозначает скалярную переменную. C<\> - специальный потому что
он используется в escape-последовательности, как показано выше. Вот как
обрабатываются специальные символы  C<]$\>:

   /[\]c]def/; # найдет ']def' или 'cdef'
   $x = 'bcr';
   /[$x]at/;   # найдет 'bat', 'cat', или 'rat'
   /[\$x]at/;  # найдет '$at' или 'xat'
   /[\\$x]at/; # найдет '\at', 'bat, 'cat', или 'rat'

Последние два немного сложнее.  В C<[\$x]>, обратный слеш защищает символ доллара
, таким образом класс символов включает 2 символа C<$> и C<x>.
В C<[\\$x]>, обратный слеш защищен, таким образом C<$x> воспринимается
как переменная и заменяется в стиле двойных кавычек.

Специальный символ C<'-'> представляет из себя опратор диапазона внутри класса,
так что непрерывный набор символов может быть записан, как
диапазон.  С диапазоном, громоздкое C<[0123456789]> и C<[abc...xyz]>
становиться стройным C<[0-9]> и C<[a-z]>.  Вот примеры

    /item[0-9]/;  # найдет 'item0' или ... или 'item9'
    /[0-9bx-z]aa/;  # найдет '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0-9a-fA-F]/;  # найдет шестнадцатиричную цифру
    /[0-9a-zA-Z_]/; # найдет символ "слова",
                    # которое совпрадает с именем переменной в Perl

Если C<'-'> будет первым или последним символом в классе символов, то он
считается обычным тире; C<[-ab]>, C<[ab-]> и C<[a\-b]> эквивалентны.

Специальный символ C<^> в первой позиции класса
означает I<отрицание класса символов>, которое найдет любой символ, который не присутствует
 в списке в квадратных скобках.  Оба и C<[...]> и C<[^...]> должны найти символы
 или поиск будет неудачным. Тогда

    /[^a]at/;  # не найдет 'aat' или 'at', но найдет
               # все другие 'bat', 'cat, '0at', '%at', и т.д.
    /[^0-9]/;  # найдет нецифровой символ
    /[a^]at/;  # найдет 'aat' или '^at'; здесь '^' - обычный символ

Теперь, даже писать несколько раз C<[0-9]> может надоесть , так
появляется интерес сократить число нажатий клавиш и сделать 
регулярные выражения удобочитаемыми,  Perl
имеет несколько сокращений для общих классов символов, как показано ниже.
С момента введения Юникода, если нет модификатора  C<//a>, то
этот класс символов найдет больше, чем просто несколько символов в
диапазоне ASCII.

=over 4

=item *

\d найдет цифру, не только [0-9] но еще и цифры нероманских языков

=item *

\s найдет пробельный символ, набор [\ \t\r\n\f] и другие

=item *

\w найдет словесный символ (буквацифру или _), не только [0-9a-zA-Z_]
но и цифры и символы из нероманских языков

=item *

\D отрицает \d; представляет другие символы, отличные от цифр, или [^\d]

=item *

\S отрицает \s; представляет любой непробельный символ [^\s]

=item *

\W отрицает \w; представляет любой несловесный символ [^\w]

=item *

Точка '.' найдет любой символ, кроме "\n" (пока не работает модификатор C<//s>, 
как объясняется позднее).

=item *

\N, как и точка, найдет любые символы кроме "\n", но делает это
 независимо, даже, если присутствует модификатор C<//s>.

=back

Модификатор C<//a> появился начиная с  Perl 5.14,  используется, 
чтобы ужесточить поиск \d, \s, и \w и только в ASCII диапазоне.
Полезно не полностью переводить вашу программу на полный Юникод
( в частности и по вопросам безопасности ), когда все, что вам нужно,
 это обработка английскоподобных текстов. ("a" может быть удвоено ,
 используйте C<//aa>, чтобы сделать больше ограничений , предотвращая регистрозависимый поиск
ASCII в не-ASCII символах; в противном случае Юникодный "символ Кельвина"
будет бессистемно соответствовать "k" или "K".)


Сокращения C<\d\s\w\D\S\W> могут быть использованы, как внутри, так и снаружи
класса символов.  Вот примеры использования:

    /\d\d:\d\d:\d\d/; # найдет время в формате hh:mm:ss
    /[\d\s]/;         # найдет любую цифру или пробельный символ
    /\w\W\w/;         # найдет словесный символ, за которым несловесный символ,
                      # за которым символ слова
    /..rt/;           # найдет любые 2 символа и за ними 'rt'
    /end\./;          # найдет 'end.'
    /end[.]/;         # также найдет 'end.'

Т.к. точка это метасимвол, его нужно заэскейпить, чтобы найти обычную точку. 
Поэтому, например, C<\d> и C<\w> - это наборы символов
, неверно думать, о C<[^\d\w]> как C<[\D\W]>; фактически
 C<[^\d\w]> тоже, что и C<[^\w]>, что тоже самое, что и C<[\W]>. 
 Думайте законами Де Моргана!

Якорь удобен в базовых регекспах I<якорь границы  слова>
C<\b>.  Находит границу между словным символом и и несловным символом
 C<\w\W> или C<\W\w>:

    $x = "Housecat catenates house and cat";
    $x =~ /cat/;    # найдет cat в 'housecat'
    $x =~ /\bcat/;  # найдет cat в 'catenates'
    $x =~ /cat\b/;  # найдет cat в 'housecat'
    $x =~ /\bcat\b/;  # найдет 'cat' в конце строки

Замечание к последнему примеру, конец строки здесь подразумевает и конец слова.

Вы можете спросить, почему C<'.'> найдет все, кроме C<"\n"> - почему не все символы? 
Причина в том, что часто при сравнении со строкой
хотят игнорировать символы новой строки. К примеру,
в то время как строка C<"\n"> представляет одну строку, мы хотели бы думать о ней, как о пустой строке.
Тогда

    ""   =~ /^$/;    # найдет
    "\n" =~ /^$/;    # найдет, $ якорь после "\n"

    ""   =~ /./;      # не найдет; требуется символ
    ""   =~ /^.$/;    # не найдет; требуется символ
    "\n" =~ /^.$/;    # не найдет; требуется символ отличный от "\n"
    "a"  =~ /^.$/;    # найдет
    "a\n"  =~ /^.$/;  # найдет, $ якорь после "\n"

Такое поведение удобно, потому что мы обычно хотим игнорировать
символы новой строки, когда мы рассчитываем найти символы в строке. Иногда,
однако мы хотим отслеживать символы новой строки. Мы, возможно, даже хотим поставить
C<^> и C<$> как якорь в начале и в конце линий в пределах
строки, а не только начало и конец строки. Perl
позволяет нам выбирать между игнорированием и обращением внимания на символ новой строки
с помощью модификаторов C<//s> и C<//m>. C<//s> и C<//m>
устанавливается для 
однострочной и многострочной строки и они определяют, рассматривать ли строку
, как одну непрерывной линию или как набор линий. Два
модификаторы влияют на два аспекта того, как регексп будет интерпретироваться: 
1) как C<'.'> определяется класс символов и 2) где могут найтись якори C<^>
и C<$>. Ниже приведены четыре возможных комбинации:

=over 4

=item *

без модификаторов (//): Поведение по умолчанию.  C<'.'> найдет любой символ кроме
C<"\n">.  C<^> найдет только начало строки и
C<$> найдет только конец или перед новой строкой в конце.

=item *

s модификатор (//s): Представляет строку как единую длинную линию.  C<'.'> найдет
любой символ, даже C<"\n">.  C<^> найдет только начало строки
и C<$> найдет только конец перед началом новой строки в конце.

=item *

m модификатор (//m): Представляет строку как набор строк.  C<'.'>
найдет любой символ, кроме C<"\n">.  C<^> и C<$> могут найти
начало и конец I<любой> линиии внутри строки.

=item *

оба модификатора s и m (//sm): Представляют строку как одну длинную линию, но 
позволяют найти множество строк.  C<'.'> найдет любой символ, даже
C<"\n">.  C<^> и C<$>, тем не менее, могут найти начало и конец
 I<любой>  линии внутри строки.

=back

Вот примеры C<//s> и C<//m> в действии:

    $x = "There once was a girl\nWho programmed in Perl\n";

    $x =~ /^Who/;   # не найдет, "Who" не является началом строки
    $x =~ /^Who/s;  # не найдет, "Who" не является началом строки
    $x =~ /^Who/m;  # найдет, "Who" является началом второй строкиm
    $x =~ /^Who/sm; # найдет, "Who" является началом второй строкиm

    $x =~ /girl.Who/;   # не найдет, "." не найдет "\n"
    $x =~ /girl.Who/s;  # найдет, "." найдет "\n"
    $x =~ /girl.Who/m;  # не найдет, "." не найдет "\n"
    $x =~ /girl.Who/sm; # найдет, "." найдет "\n"

Большую часть времени, поведение по умолчанию - это то, что мы хотели, но C<//s> и
C <//m>, иногда очень полезны. Если используется C<//m>, началу
строки по-прежнему может быть сопоставлен C<\A> и в конец строки
все еще может быть сопоставлен с якорем C<\Z> (найти оба конец строки и
символ новой строки перед ним, подобно C<$>) и C<\z> (находит только конец строки):

    $x =~ /^Who/m;   # найдет, "Who" в начале строки
    $x =~ /\AWho/m;  # не найдет, "Who" не является началом всей строки

    $x =~ /girl$/m;  # найдет, "girl" в конце первой строки
    $x =~ /girl\Z/m; # не найдет, "girl" не является концом всей строки

    $x =~ /Perl\Z/m; # найдет, "Perl" это новая строка в конце всей строки поиска
    $x =~ /Perl\z/m; # не найдет, "Perl" не в конце строки

Теперь мы знаем, как сделать выбор среди классов символов в
регекспе. Как насчет выбора среди словесных или символьных строк? Такие
варианты описаны в следующем разделе.

=head2 Найти то или это

Иногда мы хотим, чтобы наш регексп имел возможность искать разные
 слова или символьные строки. Это достигается с помощью метасивола B<или> C<'|'>.
  Чтобы найти C<dog> или C<cat>, мы создаем регекс
C<dog|cat>. Как и прежде, Perl пытается найти соответствие в самом раннем месте строки.  В каждой позиции символа
Perl сначала пытается сопоставить первую альтернативу, C<dog>.  Если
C<dog> не найден, Perl теперь пробует следующую альтернативу, C<cat>.
Если C<cat> тоже не находит, тогда поиск считается неудавшимся и Perl перемещается к следующей позиции в строке.
Вот ряд примеров:

    "cats and dogs" =~ /cat|dog|bird/;  # найдет "cat"
    "cats and dogs" =~ /dog|cat|bird/;  # найдет "cat"

Даже при том, что  C<dog> является первой альтернативой во втором регексе,
C<cat> находится раньше в строке.

    "cats"          =~ /c|ca|cat|cats/; # находит "c"
    "cats"          =~ /cats|cat|ca|c/; # найдет "cats"

В данном положении символов, уже первый элемент из списка позволяет поиску
завершиться успешно. Если некоторые варианты усекают другие, то
располагайте самые длинные вперед, чтобы дать им шанс найтись.

    "cab" =~ /a|b|c/ # найдет "c"
                     # /a|b|c/ == /[abc]/

Последний пример показывает, что символьные классы подобны 
 альтернативным символам. В данной символьной позиции первая
альтернатива позволяет регекспу  успешно завершить поиск.

=head2 Группировка элементов и иерархический поиск

Чередование позволяет регекспу выбирать среди альтернатив, но 
само по себе это является неудовлетворительным. Причина в том, что каждый вариант представляет собой единый
регексп, но иногда мы хотим альтернатив для части регекспа.
Например, предположим, мы хотим искать housecats или
housekeeper. Регексп C<housecat|housekeeper> вписывается в нашу задачу, но является
неэффективным, потому что нам пришлось дважды писать C<house>. Было бы неплохо
иметь постоянную часть регекспа С<house> , а другие части будут иметь альтернативу, как C<cat|keeper>.

B<Группирующие> метасимволы C<()> решают эту проблему. 
Группировка позволяет рассматривать части регекса как отдельную единицу.
Части регекса сгуппированы по ограждающим их скобкам. Таким образом
 мы можем заменить регексп C<housecat|housekeeper> на C<house(cat|keeper)>.
 Регексп C<house(cat|keeper)>означает поиск
C<house> за которым следует либо C<cat> либо C<keeper>.  Вот несколько примеров

    /(a|b)b/;    # найдет 'ab' или 'bb'
    /(^a|b)c/;   # найдет 'ac' в начале строки или 'bc' где угодно

    /(a|b)b/;    # найдет 'ab' или 'bb'
    /(ac|b)b/;   # найдет 'acb' или 'bb'
    /(^a|b)c/;   # найдет 'ac' в начале строки или 'bc' где угодно
    /(a|[bc])d/; # найдет 'ad', 'bd', или 'cd'

    /house(cat|)/;  # найдет или 'housecat' или 'house'
    /house(cat(s|)|)/;  # найдет или 'housecats' или 'housecat' или
                        # 'house'. Обратите внимание на то, что группы могут быть вложены.

    "20" =~ /(19|20|)\d\d/;  # находит пустой элемент выбора '()\d\d',
                             # т.к. '20\d\d' не может найти

Группирующие метасимволы C<()> позволяют еще извлекать части найденной строки. Каждые найденные группы попадают в специальные переменные C<$1>, C<$2>, и т.д.
Они могут быть использованы как обычные переменные:


Элементы выбора ведут себя одинаково как в группах, так и вне их: в данной
позиции строки, крайняя левая альтернатива позволяет регекспу выполнить поиск.
Так, в последнем примере на первой позиции строки C<"20"> соответствует второй вариант,
но нет ничего слева, чтобы найти следующие две цифры C<\d\d>. 
Поэтому Perl переходит к следующему элементу выбора, 
которым является null и это работает, так как
C<"20"> состоит из двух цифр.

Процесс пытается найти первый элемент выбора, смотрит, есть ли совпадение, и
переходя к следующему элементу, при этом возвращаясь в строке
 где попробовали предыдущую альтернативу,если она была неудачна, это называется
I<возвратом> (I<backtracking>). Термин "возврат" приходит от идеи,
что поиск регекспа похож на прогулку в лесу. Успешный поиск регекспа
 это как это как прибытие в пункт назначения. Существует множество возможных
троп одна для каждой позиции строки и каждая из них пытался в
порядке слева направо. У каждой тропы может быть много путей,
некоторые из них успешные, а некоторые являются тупиками. Когда вы
прогуливаетесь по тропе и попадаете в тупик, вам придется отступать вдоль
тропы до более ранней точки, чтобы попробовать другой след. Если вы доберетесь до пункта
назначения, вы немедленно остановитесь и забудете об остальных тропах.
Вы стойкие и только, если вы попробовали все трассы от 
всех троп и не прибудете в пункт назначения,
вы объявляете провал. Чтобы быть конкретным, вот пошаговый анализ того,
что делает Perl, когда он пытается найти регексп

    "abcde" =~ /(abd|abc)(df|d|de)/;

=over 4

=item 0

Начинает с первой буквы в строке 'a'.

=item 1

Пробует первый вариант в первой группе 'abd'.

=item 2

Находим, что после 'a' следует 'b'. Пока все в порядке.

=item 3

'd' в регекспе regexp не соответствует 'c' в последовательности - мертвый
конец. Так возвращаются два знака и выбирают вторую альтернативу в
первой группе 'abc'.

=item 4

Находим 'a' за которым 'b' за которым 'c'. Еще один успех (We are on a roll) 
и поймали первую группу. Устанавливаем 1$ в 'abc'.

=item 5

Переходим ко второй группе и выбираем первый вариант 'df'.

=item 6

Находим 'd'.

=item 7

регексп 'f' не не соответствует 'e' в строке, поэтому это мертвый
конец. Возвращаемся на один символ и выбираем второй вариант во
второй группе 'd'.

=item 8

'd' найдено. Вторая группировка найдена, и $2 равна 'd'.

=item 9

Мы в конце регекспа, и так, мы сделали это! Мы нашли
 'abcd' в строке "abcde".

=back

Есть несколько важных вещей,которые стоит сказать об этом анализе. Во-первых,
третий вариант во второй группе 'de' также находится, но мы
останавливаемся прямо перед ним,в данной позиции символ слева
выигрывает. Во-вторых, мы могли получить успешный поиск с позиции первого символа
 строки 'a'. Если бы не было совпадений на первой
позиции, Perl будет двигаться на вторую позицию символа 'b' и
попытается найти все снова. Только, когда все возможные пути на всех
возможных позициях символов были исчерпаны, Perl сдается
 и объявляет S<C<$string =~ /(abd|abc)(df|d|de)/;>> ложным.

Даже с этой работой соответствие регекспу происходит удивительно быстро. Чтобы это
ускорить, Perl компилирует регексп в компактную последовательность
опкодов, которые часто могут поместиться внутри кэша процессора. Когда код выполняется
, эти опкоды могут потом выполняться на полной скорости и искать очень
быстро.

=head2 Извлечение найденного

Метасимволы группировки  C<()> также служат для совершенно другой
 функции: они позволяют извлекать частей найденной строки.
Бывает  очень полезно узнать, что найдено и 
в целом для обработки текста. Для каждой группы, часть, найденная внутри скобок
 кладется в специальные переменные  C<$1>, C<$2>, и др. Они могут
использоваться так же, как обычные переменные:

    # извлекаем часы, минуты, секунды
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # найде hh:mm:ss формат
	$hours = $1;
	$minutes = $2;
	$seconds = $3;
    }

Теперь мы знаем, что в скалярном контексте,
Now, we know that in scalar context,
S<C<$time =~ /(\d\d):(\d\d):(\d\d)/>> вернет значение правды или лжи.  
В контексте списка, однако, он вернет список найденных значений
C<($1,$2,$3)>.  Таким образом, мы можем написать код более компактно:

    # извлекаем часы, минуты, секунды
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);

Если группы в регекспе вложенные, то C <$1> получает группу с
самой левой открывающей скобкой, C <$2> следующая открывающая скобка,
и т.д. Вот регексп с вложенными группами:

    /(ab(cd|ef)((gi)|j))/;
     1  2      34

Если регексп найдет, C<$1> содержит строку, начинающуюся с
C<'ab'>, C<$2> равно либо C<'cd'> либо C<'ef'>, C<$3> равно либо
C<'gi'> либо C<'j'>, и C<$4> будет C<'gi'>, как и C<$3>,
или останется неопределенной (undefined).

Для удобства, Perl устанавливает C < $+ настроек в строку, проведенных самым высоким номером
C <$1>, C <$2>,..., который получил назначен (и несколько связанных, C <$^N>
Большинство недавно назначенное значение C <$1>, C <$2>,..., т.е. C <$1>,
C <$2>,..., связанные с правом скобка используется в
матч).
Для удобства, Perl устанавливает C<$+> для строки содержащей наивысший номер
C<$1>, C<$2>,... который был присвоен (и несколько связанных, C<$^N> со значениями
C<$1>, C<$2>,... самые недавно присвоенные; т.е. C<$1>,
C<$2>,... ассоциируются с самыми правыми закрывающимися скобками в шаблоне поиска).


=head2 Обратные ссылки

Тесно связаны с переменными поиска C<$1>, C<$2>,...,
 I<Обратные ссылки> C<\g1>, C<\g2>... Обратные ссылки являются 
соответствующими переменными, которые могут быть использованы I<внутри> регекспа. Это
действительно приятная особенность; то, что найденное в конце регулярного выражения зависит
от того, что найдено ранее в регекспе. Предположим, чт о мыраза подряд найти
слово, встречающееся в тексте два раза подряд, как 'the the'.   Следующий регексп
находит все пары 3-х буквенных слов с пробелом между ними:

    /\b(\w\w\w)\s\g1\b/;

То, что найдено в группирующих скобках присваивается \g1, таким образом такие 3-х буквенные последовательности
 используются для обоих частей.

Аналогичная задача по поиску слов, состоящих из 2-х одинаковых частей:

    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa

Регексп имеет единую группировку, которая рассматривает 4-х буквенные
комбинации, а затем 3-х буквенные сочетания и т.д. и использует C<\g1>, чтобы  искать
повторения. Хотя C<$1> и C<\g1> представляют собой то же самое, аккуратность должна быть
 в использовании соответствующих переменных поиска C<$1>, C<$2>,... только I<вне> регекспа,
  а обратных ссылок C<\g1>, C<\g2>,... только I<внутри> регекспа; не выполнение
  этих требований может привести к удивлению и неудовлетворительным результатам.

=head2 Относительные обратные ссылки

Подсчет открытых круглых скобок, чтобы получить правильный номер для
обратной ссылки приводит к ошибкам, как только есть более чем одна
группа захвата. Более удобная техника стала доступна
с Perl 5.10: относительные обратные ссылки. Для обозначения сразу
первой предыдущей группы захвата можно записать C<\g{-1}>, но следующий
последний доступен через C <\g{-2}> и так далее.

Еще одна хорошая причина, помимо чтения и поддержки кода
для использования относительных обратных иллюстрируется в следующем примере,
где используется простой шаблон для сопоставления своеобразный строк:

    $a99a = '([a-z])(\d)\g2\g1';   # найдет a11a, g22g, x33x, и так далее.

Теперь, когда мы сохранили этот шаблон как удобную последовательность, мы могли бы почувствовать
 соблазн использовать его в качестве части некоторого другого образца:

    $line = "code=e99e";
    if ($line =~ /^(\w+)=$a99a$/){   # неожиданное поведение!
        print "$1 is valid\n";
    } else {
        print "bad line: '$line'\n";
    }

Но шаблон не находится, по крайней мере не так, как можно было бы ожидать. Только
после вставки интерполированного C<$a99a> и глядя на итоговый
полный текст регекспа становится очевидным, что обратные ссылки
 приводят к неприятным последствиям. Подвыражение C<(\w+)> захватывает номер 1 и
понижает группы в C<$a99a> на один ранг. Этого можно избежать
использованием относительных обратных ссылок:

    $a99a = '([a-z])(\d)\g{-1}\g{-2}';  # безопасно для интерполяции


=head2 Именованные обратные ссылки

Perl 5.10 также представил именованные группы захвата и именованные обратные ссылки.
Чтобы присоединить имя к группе захвата, вы пишете, либо
C<<(?<name>...)>> или C<< (?'name'...) >>.  Обратную ссылку можно
потом записать, как C<\g{name}>. Это допустимо для присоединения
 одного и того же имени более чем одной группе, но потом ссылаться можно будет только на самую левую скобку из
одноименного набора. За пределами шаблона именованная 
группа захвата доступна через хэш  C<%+>.

Предположим, что нам нужно найти календарные даты, которые могут быть предоставлены в одном
из трех форматы yyyy-mm-dd, mm/dd/yyyy или dd.mm.yyyy, мы можем написать
три подходящих шаблона, когда мы используем 'd', 'm' и 'y'  ('д', 'м' и 'г') соответственно в качестве
имен групп, захватывая соответствующие компоненты даты.
Поисковая операция сочетает в себе три шаблона как альтернативу:

    $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
    $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
    $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
    for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print "day=$+{d} month=$+{m} year=$+{y}\n";
        }
    }

Если любая из альтернатив найдется, хэш  C<%+> будет содержать
три пары ключ-значение.

=head2 Альтернативные нумерация групп захвата

Еще одна техника нумерации групп (также начиная с Perl 5.10)
занимается проблемой ссылок на группы внутри набора альтернатив.
Рассмотрим шаблон для сопоставления, время суток, гражданского или военного стиля:

    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # обработка часов и минут
    }

Обработка результатов требует дополнительных выражений if для определения
где C<$1> и C<$2> или C<$3> и C<$4> содержат нужные данные. Будет
проще, если мы могли бы использовать второй вариант как номера группы 1 и 2
Ну это именно то, что дает конструкция C<(?|...)>,
поставленная вокруг целевой альтернативы. Вот расширенная версия
предыдущего шаблона:

    if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
	print "hour=$1 minute=$2 zone=$3\n";
    }

В рамках альтернативной группы нумерации, группирующие номера начинаются в той же
позиции для каждой альтернативы. Внутри групп нумерация продолжает
 повышаться до максимума внутри всех альтернатив.

=head2 Информация о позиции

В дополнение к тому, что было найдено, Perl также предоставляет позицию
 того, что было найдено, как содержание массивов C<@-> и C<@+>.
 C<$-[0]> является положением начала всего поиска и
C<$+[0]>  является положением конца. Точно так же  C<$-[n]>
это положение старта  C<$n> -го поиска и C<$+[n]>  является конечной позицией.
Если C<$n> не определен, то нет C<$-[n]> и C<$+[n]>. Тогда
этот код

    $x = "Mmm...donut, thought Homer";
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # найдено
    foreach $expr (1..$#-) {
        print "Найдено $expr: '${$expr}' в позиции ($-[$expr],$+[$expr])\n";
    }

напечатает

    Найдено 1: 'Mmm' в позиции (0,3)
    Найдено 2: 'donut' в позиции (6,11)

Даже, если есть нет группировок в регекспе,  еще можно
узнать, что точно найдено в строке. Если вы используете их, Perl
установит C<$`> как часть строки до найденной, а C<$&> 
 как найденную строку, а в переменную C<$'> часть
строки после найденной строки. Пример:

    $x = "the cat caught the mouse";
    $x =~ /cat/;  # $` = 'the ', $& = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $& = 'the', $' = ' cat caught the mouse'

Во втором поиске, C<$`> равно C<''>, потому что регексп находит 
первый символ в строке и останавливается; он никогда не видел
второй 'the'.  Важно отметить, что использование C<$`> и C<$'>
лишь немного замедляет процесс поиска регекспа, то C<$&> замедляет его еще больше
, потому что если они используются в одном регекспе в программе,
они создаются для I<всех> регекспов в программе. Таким образом, если
 целью приложения является производительность, их следует избегать.
Если вам необходимо извлечь соответствующие подстроки, используйте  C<@-> и
C<@+> вместо этого:

    $` тоже, что и substr( $x, 0, $-[0] )
    $& тоже, что и substr( $x, $-[0], $+[0]-$-[0] )
    $' тоже, что и substr( $x, $+[0] )

Начиная с Perl 5.10  могут использоваться переменные C<${^PREMATCH}>, C<${^MATCH}> и C<${^POSTMATCH}>.
Они устанавливаются только, если присутствует модификатор C</p> .
Следовательно, они не наказывают остальную часть программы.

=head2 Не захватывающие группировки

Группа, которую требуется связать в набор альтернатив может быть как с захватом, так и без.
Если захват не нужен, то он создает лишние переменные к набору доступных для захвата групп, внутри, а также
за пределами регекспа. Незахватывающие группировки, обозначаются C<(?:regexp)> и
по-прежнему позволяют регекспу рассматривать себя как единое целое, но не установливать
 группу для захвата в то же время. И захватывающие и незахватывающие
группировки могут сосуществовать в одном и  том же регекспе. Потому что
не вытаскивающая, незахватывающая группировка быстрее, чем захватывающая.
Незахватывающие группировки также удобны для выбора того, 
какие части регулярного выражения должны быть извлечены для в переменные сопоставления:

    # найти число, $1-$4 установлены, но мы хотим только $1
    /([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/;

    # поиск значительно быстрее , установлена только $1
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/;

    # найти число, в $1 = целое число, $2 = экспонента
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/;

Незахватывающие группировки также полезны для удаления шумных
элементы, полученные от операции split где скобки 
требуются по какой-либо причине:

    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','a','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')


=head2 Поиск повторений

Примеры в предыдущей секции показывают раздражающую слабость. Мы
только распознавали 3-буквенные слова или куски слов из 4-х букв или менее.
Мы хотели бы распознать слова или, более широко, последовательности
 любой длины, не выписывая утомительные альтернативы такие, как
C<\w\w\w\w|\w\w\w|\w\w|\w>.

Для решения этой проблемы были созданы I<повторительные> метесимволы  C<?>,
C<*>, C<+>, и C<{}>.  Они позволяют нам изменять
число повторений для части регекспа, которым мы собираемся искать.
Повторители идут сразу за символом, символьным
классом или группировкой, которую мы хотим определить. У них есть следующие
значения:

=over 4

=item *

C<a?> означает: найти 'a' 1 или 0 раз

=item *

C<a*> означает: найти 'a' 0 или более раз, то есть число любое число раз

=item *

C<a+> означает: найти 'a' 1 или более раз , то есть как минимум один раз

=item *

C<a{n,m}> означает: найти по крайней мере C<n> раз, но не более C<m>.

=item *

C<a{n,}> означает: найти по крайней мере C<n> или больше раз

=item *

C<a{n}> означает: найти точно C<n> раз

=back

Вот несколько примеров:
слово строчная, по крайней мере один пробел, и
# любое количество цифр

    /[a-z]+\s+\d*/;  # найти слово в нижнем регистре, по крайней мере один пробел, и
                     # любое количество цифр
    /(\w+)\s+\g1/;    # матч двойное слово произвольной длины
    /y(es)?/i;       # найти 'y', 'Y', или 'yes' без учета регистра
    $year =~ /^\d{2,4}$/;  # удостоверьтесь, что год - по крайней мере 2, но не больше
                           # 4 цифр
    $year =~ /^\d{4}$|^\d{2}$/;    #  # лучшее совпадение; исключает дату из 3 цифр
    $year =~ /^\d{2}(\d{2})?$/;  #то же самое, написанное по-другому. Однако,
                                 # это захватывает последние две цифры в $1,
                                 # а другие нет.

    % simple_grep '^(\w+)\g1$' /usr/dict/words   # разве это не проще?
    beriberi
    booboo
    coco
    mama
    murmur
    papa

Для всех этих повторителей Perl будет пытаться искать строку настолько долго насколько это возможно
пока все еще регексп будет этому соответствовать. Таким образом
с  C</a?.../> Perl сначала попытается найти регексп с C<a>, если это не удается, 
Perl будет пытаться искать регексп  без C<a>.
Для повторителя C<*> мы получаем следующее:

    $x = "the cat in the hat";
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'

Как мы и ожидали, поиск находит только 
строку C<cat> и останавливается на этом.
Хотя этот регексп:

    $x =~ /^(.*)(at)(.*)$/; # найдет,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 символов найдено)

В начале может показаться, что Perl найдет C<at> в C<cat> и на этом остановится,
но это не даст максимальной длины для первого повторителя C<.*>.
Вместо этого первый повторитель  C<.*> захватывает строку настолько много
насколько это возможно, пока регексп еще будет соответствовать этой строке.
В этом примере, это означает, что последовательность C<at> захватит 
 последний C<at> в строке.Другой важный принцип, показанный здесь в том, что,
когда есть два или более элемента в регекспе, I<самый левый>
повторитель,если он один, захватывает строку настолько много насколько это возможно
, оставляя остальной части регекспа бороться за обрывки строки. 
Таким образом в нашем примере, первый повторитель квантор C<.*>
захватывает большую часть последовательности, в то время как
второй повторитель C<.*> получает пустую последовательность. Повторители, захватывающие
 настолько много, насколько это возможно называют  I<максимальным поиском> или
I<жадными> потворителями.

Когда регексп может соответствовать строке несколькими различными способами, мы можем использовать
принципы выше, чтобы предсказать, каким образом регексп будет искать:

=over 4

=item *

Принцип 0: Взятый в целом, любой регексп будет искать
самое раннее положение в строке.

=item *

Принцип 1: В случае альтернативы C<a|b|c...>, если найдена крайняя левая альтернатива, то
найден весь регексп.

=item *

Принцип 2: Повторители максимального поиска C<?>, C<*>, C<+> и
C<{n,m}> будут искать строку настолько долго (вперед) насколько это возможно и
 пока эта строка будет соответствовать всему регекспу.

=item *

Принцип 3: Если есть два или более элемента в регекспе,
самый левый жадный повторитель, если такой есть,
будет искать строку настолько долго насколько это возможно,
пока весь регексп регексп будет соответствовать этому поиску.
Следующий самый левый жадный потворитель, если есть,
постарается найти настолько много насколько это возможно
из оставшейся строки, пока эта строка будет соответсвовать регекспу.
И так далее, до тех пор, пока все элементы регекспа не будут 
удовлетворены.

=back

Как мы видели выше, принцип 0 переопределяет другие. Регексп
будет соответствовать как можно скорее, с другими принципами
определения такими, как, что регексп ищет самую ранню позицию символа.

Вот пример этих принципов в действии:

    $x = "The programming republic of Perl";
    $x =~ /^(.+)(e|r)(.*)$/;  # найдет,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'

Регексп ищет наиболее раннюю позицию в строке, C<'T'>. 
Кто-то может подумать, что C<e>, будет самой левой альтернативой, которая будет найдена
, но C<r> производит наиболее длинную строку в первом повторителе.

    $x =~ /(m{1,2})(.*)$/;  # найдет,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'

Здесь самый ранний возможный поиск будет первая  C<'m'> в
C<programming>. C<m{1,2}> первый повторитель, таким образом он найдет максимальные C<mm>.

    $x =~ /.*(m{1,2})(.*)$/;  # найдет,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'

Здесь регексп ищет с начала строки. Первый повторитель C<.*> 
забирает настолько много насколько это возможно , оставляя лишь одну
C<'m'> для второго повторителя C<m{1,2}>.

    $x =~ /(.?)(m{1,2})(.*)$/;  # найдет,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'

Здесь, C<.?> съест максимально один символ в самой ранней возможной позиции строки,
 это будет C<'a'> в C<programming>, Оставляя C<m{1,2}>
возможность нати оба C<m>. Наконец,

    "aXXXb" =~ /(X*)/; # найдет $1 = ''

потому что он может найти ноль копий C<'X'> в начале строки.
Если вы определенно хотите найти по крайней мере один C<'X'>, 
используйте C<X+>, не C<X*>.

Иногда жадность не очень хороша. Время от времени мы хотели бы иметь повторители для
поиска I<минимальной> части строки, а не максимальной. Для
этих целей Лари Волл создал I<минимальный поиск> или
I<не-жадные> потворители C<??>, C<*?>, C<+?>, и C<{}?>.  
К обычным повторителям добавляется C<?>. Они имеют следующие значения:

=over 4

=item *

C<a??> означает: найти 'a' 0 или 1 раз. Попробуй 0 в начале, потом 1.

=item *

C<a*?> означает: найти 'a' 0 или больше раз, т.е., любое число раз,
но настолько мало насколько это возможно

=item *

C<a+?> означает: найти 'a' 1 или больше раз, т.е., как минимум один, но 
настолько мало насколько это возможно

=item *

C<a{n,m}?> означает: найти как минимум C<n> раз, не больше, чем C<m>
раз, настолько мало насколько это возможно

=item *

C<a{n,}?> означает: найти как минимум C<n> раз, но  
настолько мало насколько это возможно

=item *

C<a{n}?> означает: найти точно C<n> рвзs. Т.к. мы находим точно
C<n> раз, C<a{n}?> эквивалентно C<a{n}> и есть только для нотационной консистенции.

=back

Давайте посмотрим на пример выше, но с минимальными повторителями:

    $x = "The programming republic of Perl";
    $x =~ /^(.+?)(e|r)(.*)$/; # найдет,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'

Минимальная строка позволяет найти одновременно и начало строки
 C<^> и первая скобка найдет C<Th>, а в альтернативе C<e|r>
найдется C<e>.  Второй повторитель C<.*> теперь свободен 
съесть оставшуюся часть строки.

    $x =~ /(m{1,2}?)(.*?)$/;  # найдет,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'

Первую позиция строки, которую регексп находит это 
C<'m'> в C<programming>. В этой позиции, минимальному  C<m{1,2}?>
соответствует только один C<'m'>. Хотя второй повторитель C<.*?>
предпочитает поиск без символов, он ограничен якорем конца строки
C<$> и находит всю оставшуюся строку.

    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # найдет,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'

В этом регекспе, вы могли бы ожидать, что первый минимальный повторитель C<.*?>
 найдет пустую строку, потому что он не ограничен якорем C<^> в начале слова. 
Однако, здесь применяется принцип 0.
Потому что, если возможно для регекспа найти от начала строки,
он I<найдет> с начала строки. Таким образом
первый повторитель должен соответствовать всему до первого C<m>. 
Второй минимальный потворитель находит только один  C<m> и третий
повторитель соответствует остальной части строки.

    $x =~ /(.??)(m{1,2})(.*)$/;  # найдет,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'

Как и в предыдущих регекспах, первый повторитель квантификатор C<.??> может соответствовать
самой ранней позиции C<'a'> и он это делает. Второй повторитель
жадный, так что он совпадает C<mm>, и третий соответствует остальной части
строки.

Мы можем изменить принцип 3 выше, принимая во внимание не-жадные (щедрые)
потворители:

=over 4

=item *

Принцип 3: Если есть два или более элемента в регекспе,
крайний слева жадный  (не жадный) повторитель, если таковые имеются, 
будет соответствовать наиболее длинной (короткой) части
насколько это позволяет соответствовать всему регекспу. 
Следующий крайний слева жадный (не жадный) повторитель, если
 есть, будет пытаться соответствовать наиболее длинной (короткой) части оставшейся строки
 насколько это возможно, пока все еще позволяя соответствовать всему регекспу. 
И так далее, пока не будут выполнены все элементы регекспа.

=back

Так же как чередование, повторители также чувствительны к
поиску с возвратом. Вот пошаговый анализ примера

    $x = "the cat in the hat";
    $x =~ /^(.*)(at)(.*)$/; # найдет,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 найдено)

=over 4

=item 0

Начинаем с первой буквы в строке 't'.

=item 1

Первый повторитель '.*' начинает совпадать с целой строкой
'the cat in the hat'.

=item 2

'a' в элементе регекспа 'at' не находится в конце строки.
Возвращаемся на один символ назад.

=item 3

'a' в элементе регекспа 'at' еще не совпадает с последним символом
 't', таким образом возвращаемся еще на один символ.

=item 4

Теперь мы можем найти 'a' и 't'.

=item 5

Переходим к третьему элементу '.*'. Поскольку мы находимся в конце
строки и '.*' может найтись 0 раз, то ему присваивается пустая строка.

=item 6

Мы сделали это!

=back

Большую часть времени, все эти перемещения вперед и назад происходят
быстро и поиск быстр. Есть некоторые патологические регекспы,
однако, время выполнения которых растет экспоненциально с ростом размера
строки. Типичная структура, которая взрывается в лицо имеет вид

    /(a|b+)*/;

Проблема заключается в неопределенном числе вложенных повторителей (квантификаторов). Есть много
различных способов секционирования строки на длину n между C<+> и C<*>:
одно повторение с  C<b+> длины n, два повторения с
первым C<b+> длины k и второе с длиной n-k, m повторений
чьи биты добавить до длины n, и др. На самом деле существует экспоненциальная
количество способов разделить строку в зависимости от его длины. 
Регекспу может повезти и он найдет в начале процесса, но если 
он не найдет, Perl постарается проверить  I<каждую> возможность не сдаваясь. Так что будьте
осторожнее с вложенными C<*>,  C<{n,m}>, и C<+>'s. Книга
I<Mastering Regular Expressions> Джеффри Фридла дает прекрасное
обсуждение этого и других проблем эффективности.

=head2 Притяжательные повторители

Поиск с возвратом в ходе неустанного поиска может быть
бессмысленной тратой времени. Рассмотрим простой шаблон

    /^\w+\s+\w+$/; # слово, пробел, слово

Всякий раз, когда это применяется к строке, которая не вполне соответствуют
ожиданиям шаблона например S<C<"abc  ">> или S<C<"abc  def ">>,
обработчик регулярных выражений будет отступать (выполнять возрат), примерно один раз для каждого символа
в строке. Но мы знаем, что нет никакого пути вокруг принимая I<все>
из начальных символов слова, чтобы найти первое повторение, таким образом  I<все>
пробелы должны быть съедены в средней части, и то же самое для второго
слова.

С введением I<притяжательных повторителей>  в Perl 5.10 у нас
есть способ давай инструкции движку регулярных выражений не возвращаться, с
обычными повторителями C<+>, добавляемые к ним. Это делает их скупыми
; после того, как они найдут успешное совпадение они не возвращаются обратно, чтобы найти
другое решение. Они имеют следующие значения:

=over 4

=item *

C<a{n,m}+> означает: найти как минимум C<n> раз, но не более C<m> раз,
настолько много насколько возможно, и не дает ничего больше. C<a?+> это краткая запись для
 C<a{0,1}+>

=item *

C<a{n,}+> означает: найти как минимум C<n> раз, но настолько много насколько возможно
 и не дает ничего больше. C<a*+> это краткая запись для C<a{0,}+> и 
 C<a++> это краткая запись для C<a{1,}+>.

=item *

C<a{n}+> означает: найти точно C<n> раз.  Это только для нотационной
консистенции.

=back

Эти притяжательные повторители представляют собой особый случай более общей
концепции I<независимого подвыражения>, смотрите ниже.

В качестве примера, когда притяжательный повторитель подходит мы считаем
совпадающие строки в кавычках, как они появляются в нескольких языках программирования.
Обратная косая черта используется как escape-символ, который указывает, что
следующим символ следует понимать буквально, как еще один символ для
строки. Таким образом, после открытия кавычки, мы ожидаем (возможно
пустую) последовательность альтернатив: либо некоторые символы, за исключением
неэкранированной кавычки или обратной косой черты или escape-символа.

    /"(?:[^"\\]++|\\.)*+"/;


=head2 Построение регекспа

На данный момент у нас есть все основные понятия регексп, так что давайте
дадим более сложный пример регулярного выражения. Мы будем строить
регексп, соответствующий числам.

Первая задача при создании регексп это решить, чего мы хотим найти, и
, что мы хотим исключить. В нашем случае мы хотим найти и
целые числа и числа с плавающей запятой и мы хотим отвергнуть любую строку,т.к.
это не число.

Следующая задача — разбить проблему на меньшие, которые уже
легко превратить в регексп.

Простейший случай — это целые числа. Они состоят из последовательности цифр,
с необязательным знаком впереди. Цифры, которые мы можем представлять 
C<\d+> и знак может быть найден C<[+-]>. 
Таким образом,регексп для целого числа

    /[+-]?\d+/;  # найдет целые числа

Число с плавающей точкой потенциально имеет знак, 
десятичную запятую, дробную часть и показатель степени. Один или более из этих
частей являются не обязательными, поэтому нам нужно проверить различные
возможности. Числа с плавающей запятой, которые находятся в надлежащей форме включают
123. 0,345,.34,-1e6 и 25.4E-72. Как и с целыми числами, знак
спереди совершенно необязателен и может находится  C<[+-]?>. Мы можем
увидеть, что если нет не показателя степени, числа с плавающей точкой должны иметь
десятичную запятую, в противном случае они являются целыми числами. У нас мог бы возникнуть соблазн
замоделировать это так  C<\d*\.\d*>, но это также будет соответствовать только одной
десятичной точке, которая не является числом. Таким образом вот три случая числа с плавающей
запятой без экспоненты

   /[+-]?\d+\./;  # 1., 321., etc.
   /[+-]?\.\d+/;  # .1, .234, etc.
   /[+-]?\d+\.\d+/;  # 1.0, 30.56, etc.

Они могут быть объединены в единый регексп с тройным чередованием:

   /[+-]?(\d+\.\d+|\d+\.|\.\d+)/;  # число с плавающей точкой, не с экспонентой

В этом выборе, важно поставить C<'\d+\.\d+'> перед
C<'\d+\.'>.  Если C<'\d+\.'> идет первым, регексп успешно найдется
 и проигнорирует дробную часть числа.

Теперь рассмотрим числа с плавающей запятой с экспонентой. Важным 
здесь является то, что я I<оба числа> и целые и с десятичной
запятой могут быть перед экспонентой.Тогда экспонента,
как и знак, независимоа от того ищем ли мы числа с или
без десятичной запятой и их можно 'отделить' от
мантиссы. Общая форма регекспа теперь становится ясна:

    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;

Экспонена это C<e> или C<E>, идущая перед цифрой.  Таким образом
регексп для экспоненты такой

   /[eE][+-]?\d+/;  # экспонента

Соединяя все части, мы получаем регексп, который соответствует числам:

   /^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/;  # Тадам!

Длинные регулярных выражений, как это могут впечатлить ваших друзей, но их может быть трудно
расшифровать. В сложных ситуациях, как эта, модификатор поиска C<//x>  
имеет неоценимое значение. Он позволяет поставить произвольное число пробелов
и комментариев в регулярное выражение не затрагивая его смысл. Используя его,
мы можем переписать наш 'расширенный' регексп в более приятной форме

   /^
      [+-]?         # сначала находим необязательный знак
      (             # потом находим целое или мантиссу - число с плавающей запятой:
          \d+\.\d+  # мантисса типа a.b
         |\d+\.     # мантисса типа a.
         |\.\d+     # мантисса типа .b
         |\d+       # целое в виде a
      )
      ([eE][+-]?\d+)?  # в конце, опционально, находим экспоненту
   $/x;

Если пробелы в основном не имеют значения, как вставить один из них в этот
 расширенной regexp? Ответ заключается в обратной косой черте
S<C<'\ '>>  или вставить пробел, как в классе символов  S<C<[ ]>>. То же самое
идет для знаков фунта или решетки: используйте C<\#> или C<[#]>.  Например Perl позволяет
 пробелы между знаком и мантиссой или целым числом и мы могли бы добавить
это в наш регексп следующим образом:

   /^
      [+-]?\ *      # вначале, найдем опциональный знак *и пробел*
      (             # потом находим целое или мантиссу:
          \d+\.\d+  # мантисса типа a.b
         |\d+\.     # мантисса типа a.
         |\.\d+     # мантисса типа .b
         |\d+       # целое в виде a
      )
      ([eE][+-]?\d+)?  # в конце, опционально, находим экспоненту
   $/x;

В этой форме, это легче увидеть способ упростить
чередование. Все варианты 1, 2 и 4 начинаются с C<\d+>, это можно
вынести за скобки:

   /^
      [+-]?\ *      # вначале, найдем опциональный знак
      (             # потом находим целое или мантиссу:
          \d+       # начинаем с цифры a ...
          (
              \.\d* # мантисса типа  a.b или a.
          )?        # ? заботиться о целом числе в форме a
         |\.\d+     # мантисса типа .b
      )
      ([eE][+-]?\d+)?  # в конце, опционально, находим экспоненту
   $/x;

или написанное в компактной форме:

    /^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;

Это - наш финальный регексп. Чтобы резюмировать, мы построили regexp

=over 4

=item *

определяя задачу подробно,

=item *

разделяя задачу на маленькие части,

=item *

переводя маленькие кусочки в регексп,

=item *

объединяя регекспы,

=item *

и оптимизировав финальный объединенный регексп.

=back

Это типичные шаги, которые нужно сделать, чтобы написать компьютерную
программу. Конечное выражение понятно, потому что регулярные выражения
по существу являются программами, написанные на небольшом компьютерном языке,
который описывает шаблоны поиска.

=head2 Использование регулярных выражений в Perl

Последняя тема 1 части кратко охватывает использование регулярных выражений в Perl
программах. Где они помещаются в синтаксисе Perl?

Мы уже представили соответствующий оператор по умолчанию это
C</регексп/> , а в случае произвольного разделителя C<m!регексп!> . Мы использовали
оператор привязки  C<=~>  и его отрицание  C<!~> для проверки найденной строки.
Операторы, связанные с оператором поиска, мы уже обсуждали,
 это единая линия C<//s>, многострочная строка C<//m>, без учета регистра С<//i> и
модификатор расширенного синтаксиса C<//x>. Есть несколько вещей, которые вы могли бы
захотеть узнать об операторах поиска.

=head3 Запрет замены

Если вы измените  C<$pattern> после первой произошедшей замены, Perl
это проигнорирует.  Если вы не хотите замен вообще, используйте
cпециальный разделитель C<m''>:

    @pattern = ('Seuss');
    while (<>) {
        print if m'@pattern';  # найде строку '@pattern', не 'Seuss'
    }

Подобно строкам, C<m''> действует как апостроф на регексп; все другие
разделители C<m> действуют как цитаты. Если выражение оценивается как пустая строка,
вместо этого используется регексп I <последнего успешного сопоставления>. Поэтому у нас

    "dog" =~ /d/;  # найдет 'd'
    "dogbert =~ //;  # это найдет 'd' , как и предыдущий регексп


=head3 Глобальный поиск

Здесь мы будем обсуждать последние 2 модификатора, касающиеся поиска
C<//g> и C<//c>.
Модификатор C<//g> нужен для глобального поиска и позволяет
найти шаблон в строке столько раз, насколько это возможно.
В скалярных контексте при C<//g> будут последовательные вызовы в искомой строке
 от одного удачного совпадения к другому, удерживая позицию в искомой строке 
 по мере продвижения вперед. Вы можете получить или задать положение в строке 
 с помощью функции C<pos()>.

В следующем примере показано использование C<//g>. Предположим, что у нас есть
строка, которая состоит из слов, разделенных пробелами. Если мы знаем число
слов заранее, то мы могли бы извлечь слова, используя группировки:

    $x = "cat dog house"; # 3 слова
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # найдет,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'

Но что делать, если мы имеем неопределенное число слов? Для этого рода
задач сделан модификатор C<//g>. Чтобы извлечь все слова, образуют простой
регексп C<(\w+)> и цикл по всем найденным шаблонам в строке C</(\w+)/g>:

    use utf8;
    use Encode::Locale;

    if (-t) 
    {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
    
    while ($x =~ /(\w+)/g) {
        print "Слово $1, оканчивается в позиции ", pos $x, "\n";
    }

напечатает

    Слово cat, оканчивается в позиции 3
    Слово dog, оканчивается в позиции 7
    Слово house, оканчивается в позиции 13

Неудачный поиск или изменение целевой строки для поиска сбрасывает позицию. Если
вы не хотите сбрасывать позицию после неудачного поиска добавте
C<//c>, как в C</регексп/gc>. Текущая позиция в строке
связывается со строкой, а не с регекспом. Это означает, что разные
строки имеют разные позиции и их соответствующие позиции можно
задать или прочитать независимо.

В списочном контексте C<//g> возвращает список найденных группировок, или если
нет групп, список совпадений во всем регекспе. Так что, если
мы хотим найти только слова, мы можем использовать

    @words = ($x =~ /(\w+)/g);  # найдет,
                                # $words[0] = 'cat'
                                # $words[1] = 'dog'
                                # $words[2] = 'house'

Тесно связан с модификатором C<//g> якорь C<\G> . Якорь C<\G> находит позицию, где предыдущий
C<//g> в поиске был выключен. 
C<\G> позволяет нам легко сделать контекстно-чувствительный поиск:

    $metric = 1;  # использовать метрические единицы
    ...
    $x = <FILE>;  # читать в измерение
    $x =~ /^([+-]?\d+)\s*/g;  # получить величины
    $weight = $1;
    if ($metric) { # проверка ошибок
        print "Units error!" unless $x =~ /\Gkg\./g;
    }
    else {
        print "Units error!" unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # продолжаем обработку

Сочетание С<//g> и С<\G> позволяет позволяет нам обрабатывать последовательность бит 
за один раз и использовать произвольную логику Perl, чтобы решить, что делать дальше.
В настоящее время, якорь C<\G> полностью поддерживается  только тогда, когда используется якорь для привязки
к  началу шаблона.

C<\G> также неоценим в обработке отчетов фиксированной длины 
регекспами. Предположим, что у нас есть отрывок кодирования ДНК области, закодированной как
письма о паре оснований C<ATCGTTGAAT...>  и мы хотим найти всю остановку
кодоны C<TGA>. В кодирующем регионе кодоны - 3-буквенные последовательности, таким образом,
мы можем думать об отрывке ДНК как о последовательности 3-буквенных отчетов.
наивный регексп

    # расширенный, это "ATC GTT GAA TGC AAA TGA CAT GAC"
    $dna = "ATCGTTGAATGCAAATGACATGAC";
    $dna =~ /TGA/;

не работает; это может соответствоватьC<TGA>, но нет никакой гарантии, что поиск 
будет выровнен с границами кодона, например, подстрока
S<C<GTT GAA>> дает успешный поиск. Лучшее решение

    while ($dna =~ /(\w\w\w)*?TGA/g) {  # отметьте минимальное *?
        print "Получил кодон остановки TGA в позиции", pos $dna, "\n";
    }

что напечатает

    Получил кодон остановки TGA в позиции 18
    Получил кодон остановки TGA в позиции 23

Позиция 18 хорошо, но позиция 23 поддельная. Что произошло?

Ответ - то, что наш регексп работает хорошо, пока мы не заканчиваем последний
реальный поиск. Потом регексп не будет соответствовать синхронизированному C<TGA>
и начнет ступать вперед одно положение символа за один раз,а не то,что мы
хотим. Решение состоит в том, чтобы использовать якорь  C<\G> , чтобы закрепить поиск к 
выравненному кодону:

    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print "Got a TGA stop codon at position ", pos $dna, "\n";
    }

Напечатает

    Got a TGA stop codon at position 18

который является правильным ответом. Этот пример иллюстрирует, что 
важно найти не только то, что желаемо, но и отклонить то, что не
желанно.

(Есть другие модификаторы регексп , которые доступны, такие как
C<//o>, но их специализированное использование вне
объема этого введения.)

=head3 Поиск и замена

Регулярные выражения также играют большую роль в 
операциях I<поиска и замены> в Perl. Поиск и замена осуществляется 
оператором C<s///>. Общая форма C<s/регексп/замена/модификаторы>, 
, здесь применяется все, что мы знаем о регулярных выражениях и модификаторах.
C<замена> является Perl строкой в двойных кавычках, которая заменяет в
строке то, что найдет C<регексп>. Оператор C<=~> также используется 
для связывания строки с C<s///>. Если ищем в C<$_>, S<C<$_ =~>> можно опустить.
Если есть совпадение, C<s///> возвращает количество сделанных замен;
в противном случае он возвращает значение false. Вот несколько примеров:

    $x = "Time to feed the cat!";
    $x =~ s/cat/hacker/;   # $x содержит "Time to feed the hacker!"
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = "'quoted words'";
    $y =~ s/^'(.*)'$/$1/;  # удалить одиночные кавычки,
                           # $y содержит "quoted words"

В последнем примере целая строка была найдена, но только часть
в одинарных кавычках составила группу. С оператором C<s///>
 переменные  C<$1>, C<$2>, и т.д. немедленно доступны для использования
в выражении замены, таким образом, мы используем C<$1>, чтобы заменить указанную
 закавыченную строку. С глобальным модификатором, C<s///g>
будет искать и заменять все найденные части регекспа в строке:

    $x = "I batted 4 for 4";
    $x =~ s/4/four/;   # не заменит для всех:
                       # $x содержит "I batted four for 4"
    $x = "I batted 4 for 4";
    $x =~ s/4/four/g;  # заменит все:
                       # $x содержит "I batted four for four"

Если вы предпочитаете 'regex' над 'regexp' в этом учебнике, вы можете 
использовать следующую программу для замены:

    % cat > simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (<>) {
        s/$regexp/$replacement/g;
        print;
    }
    ^D

    % simple_replace regexp regex perlretut.pod

В C<простой_замене> мы используем модификатор C<s///g>, чтобы заменить все 
найденные части строки на всем блоке искомого текста. 
(Даже, если регулярное выражение появляется в цикле, Perl 
достаточно умен, чтобы скопмилировать его один раз.) 
Как с C<простым_grep>, оба
C<print> и C<s/$regexp/$replacement/g> используют C<$_> не явно.

Если вы не хотите использовать C<s///> для изменения оригинальной переменной
вы можете использовать неразрушаемый модификатор C<s///r>.  
Он изменяет поведение, так, что C<s///r> возвращает конечную измененную строку
(вместо числа замен):

    $x = "I like dogs.";
    $y = $x =~ s/dogs/cats/r;
    print "$x $y\n";

Этот пример напечатает "I like dogs. I like cats". Учтите, что начальная переменная
C<$x> не была изменена. Общий результат замены вместо этого
сохраняется в C<$y>. Если замены не происходит, то возвращается исходная строка:

    $x = "I like dogs.";
    $y = $x =~ s/elephants/cougars/r;
    print "$x $y\n"; # напечатает "I like dogs. I like dogs."

Еще одна интересная штука в том, что флаг C<s///r>  позволяет делать цепочки
замен:

    $x = "Cats are great.";
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\n";
    # напечатает "Hedgehogs are great."

C<s///e> - модификатор выполнения, существующий специально для поиска и замены. 
C<s///e> воспринимает заменемый текст,как код Perl, а не строку в двойных кавычках.
Значение, которое возвращает код подставляется
вместо найденной подстроки. C<s///e> полезно, если вам нужно сделать некоторые
вычисления в процессе замены текста. В этом примере рассчитывается
частота символов в строке:

    $x = "Bill the cat";
    $x =~ s/(.)/$chars{$1}++;$1/eg;  # конечный $1 заменяет символ на самого себя
    print "frequency of '$_' is $chars{$_}\n"
        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);

Это напечатает

    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1

Как и в операторе поиска C<m//>, оператор C<s///> может использовать другие разделители,
Например, C<s!!!> и C<s{}{}> и даже C<s{}//>. Если используются одинарные кавычки
 C<s'''>, тогда регексп regexp и замена
рассматриваются как строки в одиночных кавычках и тогда не происходит
подстановки переменных. C<s///> в списочном контексте
возвращает то же самое, как и в скалярном контексте, т.е. число найденных элементов.

=head3 Функция split


Функция C<split()>  является еще одним местом, где используется регексп.
C<split /регексп/, строка, limit> разделяет C<строку> операнд в
список подстрок и возвращает этот список. Регексп должен быть таким
, чтобы находить любые разделители для желаемых подстрок.
C<limit>, если он присутствует, накладывает ограничение на раздел не более чем C<limit>
 строк. Например чтобы разделить строку на слова, используйте

    $x = "Calvin and Hobbes";
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'

Если используется пустой регексп C<//>, то он всегда будет находиться и разделит строку 
на отдельные символы. Если регексп имеет группировки,
то результирующий список содержит совпавшие подстроки из
группировок. К примеру

    $x = "/usr/bin/perl";
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'
                                
Так как первый символ $x регексп находит, C<split> присоединяет
пустой начальный элемент к списку.

Если вы дочитали так далеко, Поздравляем! Теперь у вас есть все основные
инструменты, необходимые для использования регулярных выражений для решения 
широкого круга проблем обработки текста.
Если это ваш первый раз через учебник,
то почему бы не остановится и поиграть с регулярными выражениями какое-то время... 
 S<Часть 2> касается более эзотерических аспектов регулярных выражений и тех
концепций, которые, безусловно, не нужны в самом начале

=head1 Часть 2: Электроинструменты (Power Tools)

Отлично, вы знаете основы регулярных выражений и хотите узнать больше. Если
поиск регулярными выражениями является аналогом прогулки в лесу, тогда
инструменты, о которых говорилось в первой части, аналогичны топографическим картам и
компасу, это основные инструменты, которые мы используем все время. Большинство инструментов в части 2
аналогичны огненным пистолетам и спутниковым телефонам. Они не используются
слишком часто в походе, но когда мы застряли, они могут быть бесценными.

Ниже приводятся более продвинутые,но меньше использующиеся и даже иногда эзотерические
возможности регулярных выражений Perl. В части 2 мы предполагаем, что вы
комфортно себя чувствуете с основами и решили сосредоточить внимание на продвинутых функцииях.

=head2 Подробнее о символах, строк и о символьных классах

Существует ряд эскейп последовательностей и символьных классов, которые мы
пока еще не охватили.

Есть несколько escape-последовательностей, которые преобразуют символы или строки
в верхний и нижний регистр и они также доступны внутри шаблонов. 
C<\l> и C<\u> преобразуют следующий символ в нижний или
верхний регистр, соответственно:

    $x = "perl";
    $string =~ /\u$x/;  # найдет 'Perl' в $string
    $x = "M(rs?|s)\\."; # внимание двойной бекслеш
    $string =~ /\l$x/;  # найдет 'mr.', 'mrs.', и 'ms.',

C<\L> или C<\U> указывают на преобразование регистра, пока не встетится
завершающее C<\E> или бросаются другие C<\U> или C<\L>:

    $x = "This word is in lower case:\L SHOUT\E";
    $x =~ /shout/;       # найдет
    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
    $x =~ /\Ukeypunch/;  # найдет punch card string

Если нет C<\E>, регистр меняетя до конца строки. 
Регексп C<\L\u$word> или C<\u\L$word> конвертирует первый символ
у C<$word> в верхний регистр и оставшиеся символы в нижний регистр.

Управляющие символы могут быть заэскейплены при помощи
C<\c>, то есть символ control-Z будет найден с помощью C<\cZ>.  
Эскейп последовательносить
C<\Q>...C<\E> яляется кавычками, или защищает неалфавитные символы.
Например,

    $x = "\QThat !^*&%~& cat!";
    $x =~ /\Q!^*&%~&\E/;  # проверка на грубый язык

Но они не защищают C<$> или C<@>, таким образом переменные могут быть все еще заменены.

C<\Q>, C<\L>, C<\l>, C<\U>, C<\u> и C<\E> на самом деле часть
 синтаксиса заключения в двойные кавычки, а не часть правильного 
 синтаксиса регулярных выражений. Они будут
работать, если они появляются в регулярном выражении, встроенном непосредственно в
программу, но не когда содержащиеся в строке, которая интерполируется в
шаблон.

Perl регекспы могутт обрабатывать больше, чем просто
стандартный набор символов ASCII. Perl поддерживает I<Unicode>, стандарт
для представления письменных алфавитов из практически всех мировых
языков и множество специальных символов. Perl текстовые строки являются строками в Юникоде, таким
 образом они могут содержать символы со значением (символ или кодовым номер) выше
чем 255.

Что это значит для регулярных выражений? Ну пользователям регекспов не нужно знать
много о внутреннем представлении строк в Perl . Но они должны
знать 1) как для представляются символы Юникода в регекспе и 2),что
 операция поиска будет относиться к строке для поиска как последовательность
из символов, а не байтов. Ответ на 1), что символы Юникода
больше, чем C<chr(255)> представлены использованием C<\x{hex}> нотации, потому что
\x hex (без фигурных скобок) не идет дальше, чем 255. (Начиная с Perl
5.14, если вы поклонник восьмеричной системы, вы можете также использовать C<\o{oct}>.)

    /\x{263a}/;  # найдет Юникодный символ лица в виде смайла :)

B<ЗАМЕТЬТЕ>: В Perl 5.6.0, раньше считалось, что необходимо сказать C<use
utf8> , чтобы использовать любые функции Юникода. Это больше не так: для
почти всей обработки Юникода, явная прагма C<utf8> не нужна.
(Единственный случай, когда это имеет значение – если ваш Perl скрипт находится в
Юникоде и кодировка UTF-8, тогда явное указание C<use utf8> необходимо.)

Выяснение шестнадцатеричной последовательности Юникодного символа, который вы хотите
или расшифровка чужого шестнадцатеричного Юникодного регекспа может быть также
интересно, как программирование в машинном коде. Так что другой способ указания
символов Юникода заключается в использовании I<именованных символов> эскейп последовательности
C<\N{I<имя>}>. I<имя> — это имя для символа Юникода ,
указанного в стандарте Юникода. Например, если мы хотим узначть, что
представляют собой знак зодиака планеты Меркурий, мы
можно использовать

    $x = "abc\N{MERCURY}def";
    $x =~ /\N{MERCURY}/;   # найдет

Можно также использовать "короткие" имена:

    print "\N{GREEK SMALL LETTER SIGMA} называется сигма.\n";
    print "\N{greek:Sigma} это сигма в верхнем регистре.\n";

Можно также ограничить имена определенным алфавитом, указав
прагму L<charnames>:

    use charnames qw(greek);
    print "\N{sigma} это Греческая сигма\n";

Индекс имен символов доступен он-лайн у Юникодного Консорциума,
L<http://www.unicode.org/charts/charindex.html>; пояснительные
материалы со ссылками на другие ресурсы есть на
L<http://www.unicode.org/standard/where>.

Ответом на требование 2) является то, что регексп (в основном)
использует символы Юникода.  "По большей части" предназначен для обеспечения
грязной обратной совместимости, но начиная с Perl 5.14, любой регексп
скопилированный в области C<use feature 'unicode_strings'>
 (которая автоматически включена в сферу начиная с C<use 5.012> или выше)
 переключает "По большей части" на "Всегда".
 Если вы хотите обрабатывать Юникод должным образом, вам
следует обеспечить, что C<'unicode_strings'> включен.
Внутренне это кодируется с помощью UTF-8 или родной 8 байтовой
кодировкой, в зависимости от истории строки, но концептуально 
это последовательность символов, не байтов. Смотрите L<perlunitut>
как на учебник для этого.

Давайте теперь обсудим классы символов Юникода. Для символов Юникода
 существует именованные классы символов Юникода, представленные
 эксейп-последовательностью C<\p{name}>. Тесно связан C<\P{name}>
класс символов, который представляет собой отрицание C<\p{name}> класса. Для
примера, чтобы найти символы нижнего и верхнего регистра,

    $x = "BOB";
    $x =~ /^\p{IsUpper}/;   # найдет символьный класс в верхнем регистре
    $x =~ /^\P{IsUpper}/;   # не найдет символьный класс в верхнем регистре
    $x =~ /^\p{IsLower}/;   # не найдет, здесь символьный класс символов нижнего регистра
    $x =~ /^\P{IsLower}/;   # найдет, символьный класс, отрицающий нижний регистр

( "Is" является необязательным.)

Вот связь между некоторыми классами Perl и
традиционными классами Юникода:

    Имя класса Юникода имя класса Perl или регулярное выражение

    IsAlpha          /^[LM]/
    IsAlnum          /^[LMN]/
    IsASCII          $code <= 127
    IsCntrl          /^C/
    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
    IsDigit          Nd
    IsGraph          /^([LMNPS]|Co)/
    IsLower          Ll
    IsPrint          /^([LMNPS]|Co|Zs)/
    IsPunct          /^P/
    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
    IsUpper          /^L[ut]/
    IsWord           /^[LMN]/ || $code eq "005F"
    IsXDigit         $code =~ /^00(3[0-9]|[46][1-6])$/

ВЫ можете также использовать официальный класс Юникода с C<\p> и
C<\P>, например C<\p{L}> для Юникодных 'симолов' ('letters'), C<\p{Lu}> для символов в верхнем регистре
, или C<\P{Nd}> для нецифр.  Если C<name> это только один символ, 
скобки можно опустить. Например, C<\pM> - это символьный класс Юникодных знаков ('marks'),
например, знака ударения (диакритические). Для получения полной информации смотри L<perlunicode>.

Юникод также был разделен на различные наборы символов
которые вы можете протестировать C<\p{...}> (входит) и C<\P{...}> (не входит).
Чтобы проверить символ на вхождение (или нет) в элемент скрипта
вы должны использовать имя скрипта, например C<\p{Latin}>, C<\p{Greek}>,
или C<\P{Katakana}>.

То, что мы описали пока является единой формой C<\p{...}> 
класса символов. Существует также составные формы, с которыми вы можете столкнуться. Эти
выглядят как C<\p{name=value}> или C<\p{name:value} (знак равенства и двоеточия
могут использоваться как синонимы). Это более общее представление, чем одинарная форма,
и на самом деле для большинства одиночных форм Perl просто  дает определенные ярлыки для общих
составных форм. Наример сценарии в предыдущем пункте
могут быть написан эквивалентны  C<\p{Script=Latin}>, C<\p{Script:Greek}, и
C<\P{script=katakana}> (регистр имеет значения между фигурными скобками C<{}>). Вам возможно
никогда не придется использовать составные формы, но иногда это необходимо и их
использование может сделать ваш код более понятным.

C<\X> — это аббревиатура для класса символов, который состоит из
Юникодных I<расширенных графема кластеров>. Они представляют собой "логический символ":
то, что представляется, как один символ, но может быть внутренне представлено больше
чем одним символом. Например, с помощью полных имен Юникода, например, 
S<C<A + COMBINING RING>> — графема кластер, основанный на символе C<A> и сочетания символов
S<C<COMBINING RING>>, который переводится в датском на A с кружком на вершине,
как и слово ангстрем(Angstrom).

Полную и последнюю информацию о кодировке Юникод см. последний
стандарт Юникода, или веб-сайт консорциума Unicode L<http://www.unicode.org>.
Хорошая статья здесь L<http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G30602>.

Если и этих классов не достаточно, Perl также определяет POSIX-стиль
классов символов. Они имеют форму C<[:name:]>, где C<name>
имя класса POSIX. Классы POSIX, C<alpha>, C<alnum>,
C<ascii>, C<cntrl>, C<digit>, C<graph>, C<lower>, C<print>, C<punct>,
C<space>, C<upper>, и C<xdigit>,и два расширения, C<word>(Perl
расширение для поиска C<\w>) и C<blank>(расширение GNU). 
Модификатор C<//a> ограничивает эти соответствия только в диапазоне ASCII; в противном случае
они могут совпадать, так же, как соответствующие им классы Perl Unicode:
C<[:upper:]> такой же, как C<\p{IsUpper}>, и т.д. (есть некоторые
исключения и ошибки с этим; Смотрите полное обсуждение в L<perlrecharclass>.)
C<[:digit:]>, C<[:word:]>, и
C<[:space:]> соответствуют знакомым C<\d>, C<\w> и C<\s>
классам символов. Для инвертирования класса POSIX, поставьте  C<^> перед
именем, так что, например, C<[:^digit:]> соответствует C<\D> и, под
Юникодом, C<\P{IsDigit}>. Классы символов Unicode и POSIX могут
быть использованы так же, как C<\d>, за исключением символов POSIX
классы которых могут использоваться только внутри класса символов:

    /\s+[abc[:digit:]xyz]\s*/;  # найдет a,b,c,x,y,z, или цифру
    /^=item\s[[:digit:]]/;      # найдет '=item',
                                # за которым пробел и цифра
    /\s+[abc\p{IsDigit}xyz]\s+/;  # найдет a,b,c,x,y,z, или цифру
    /^=item\s\p{IsDigit}/;        # найдет '=item',
                                  # за которым пробел и цифра

Вау! Это уже все знаки и классы символов.

=head2 Компиляция и сохранение в переменной регулярного выражения

В 1 Части мы упоминули, что Perl компилирует регекспы в компактную
последовательность опкодов. Таким образом скомпилированное регулярное выражение 
— это структура данных, которую можно сохранить один раз и использовать снова и снова.
Кавычки регекспа
C<qr//> а точнее: C<qr/строка/> компилируют C<строку> как регулярное выражение
 и преобразуют результат в форму, которую можно можно присвоить переменной:

    $reg = qr/foo+bar?/;  # reg содержит откомпилированный регексп

Тогда C<$reg> может быть использован в регекспе:

    $x = "fooooba";
    $x =~ $reg;     # найдет, то же, что и /foo+bar?/
    $x =~ /$reg/;   # то же, альтернативная форма

C<$reg> также может быть интерполирован в больший регексп:

    $x =~ /(abc)?$reg/;  # все еще найдет

С оператором поиска C<m>, кавычки регекспа могут иметь ранообразные разделители
, т.е., C<qr!!>, C<qr{}> или C<qr~~>.  Апострофы
в качестве разделителей (C<qr''>) препятствуют интерполяции.

Предварительно скомпилированные регулярные выражения полезны для создания динамического поиска,
их не нужно перекомпилировать каждый раз, когда они встречаются. С помощью
предварительно скомпилированных регулярных выражений, мы пишем C<grep_step> программу которая ищет,
 используя серию шаблонов, передвигаясь к следующему шаблону, как только
как предыдущий был успешно найдет.

    % cat > grep_step
    #!/usr/bin/perl
    # grep_step - найдет <число> регекспов, один после другого
    # использование: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    @compiled = map qr/$_/, @regexp;
    while ($line = <>) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D

    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;

Сохранение прекомпилированных регекспов в массиве C<@compiled> позволяет нам
сделать простой цикл по регекспам без их перекомпиляции, таким образом, получается
гибкость без ущерба для скорости.

=head2 Составление регулярных выражений во время выполнения программы (runtime)

Поиск с возвратом более эффективен, чем повторение попыток поиска с различными регулярными
выражениями. Если существует несколько регулярных выражений и поиск по любому из них
 является приемлемым, то можно объединить их в набор
альтернатив. Если эти выражения подаются как входные данные, то это
 их соединение может быть сделано операцией join. Мы будем использовать эту идею в
улучшенной версии программы C<simple_grep>: программы, которая ищет
по нескольким шаблонам:

    % cat > multi_grep
    #!/usr/bin/perl
    # multi_grep - найдет любое <число> регекспов
    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    $pattern = join '|', @regexp;

    while ($line = <>) {
        print $line if $line =~ /$pattern/;
    }
    ^D

    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);

Иногда бывает выгодно построить шаблон из I<входящих данных> (I<input>)
, который будет проанализирован и использовать допустимые значения в левой стороне
 операции поиска. В качестве примера для этой несколько
парадоксальной ситуации, давайте предположим, что наши входящие данные (input) содержат команду
глагол, которая должна соответствовать одной из набора доступных команд, 
с дополнительным поворотом, что команды могут сокращаться, пока
данная строка является уникальной. Ниже программа демонстрирует основной
алгоритм.

    % cat > keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $command = <> ){
        $command =~ s/^\s+|\s+$//g;  # обрезаем лидирующие и конечные пробелы
        if( ( @matches = $kwds =~ /\b$command\w*/g ) == 1 ){
            print "command: '@matches'\n";
        } elsif( @matches == 0 ){
            print "no such command: '$command'\n";
        } else {
            print "not unique: '$command' (could be one of: @matches)\n";
        }
    }
    ^D

    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'

Вместо того, чтобы пытаться найти соответствовие входных данных и ключевых слов, мы найдем
объединенный набор ключевых слов и спопоставим его входным данным (инпуту). Операция поиска по шаблону
S<C<$kwds =~ /\b($command\w*)/g>> делает несколько вещей в одно и 
то же самое время. Чтобы быть уверенным, что команда начинается с ключевого слова, укажем (C<\b>). 
Это можно сократить из-за добавленного C<\w*>. Это
говорит нам число найденных случаев (C<scalar @matches>) и все ключевые слова, которые
 были фактически найдены.Вряд ли вы могли бы попросить больше.

=head2 Встраивание комментариев и модификаторов в регулярное выражение

Начиная с этого раздела, мы будем обсуждать набор I<расширенных шаблонов> Perl. 
Это расширения для традиционного синтаксиса регулярных выражение
, которые обеспечивают новые мощные инструменты для поиска по шаблону.
Мы уже видели расширения в виде минимального
соответствия конструкции C<??>, C<*?>, C<+?>, C<{n,m}?>, и C<{n,}?>. Большинство
из расширений ниже имеют форму  C<(?char...)>,  где
C<char> — это символ, который определяет тип расширения.

Первое расширение - это встроенный комментарий C<(?#text)>. Он вкладывает
комментарий в регулярное выражение, не затрагивая его смысл. В
комментарии не должно быть каких-либо закрывающих скобок в тексте. Например,

    /(?# Match an integer:)[+-]?\d+/;

Это стиль комментариев во многом был заменен на сырой,
свободный комментарий, который допускается при модификаторе C<//x> .

Большинство модификаторов, таких как C<//i>, C<//m>, C<//s> и C<//x> (или любой
их комбинации) также могут быть встроены в
регексп, с помощью C<(?i)>, C<(?m)>, C<(?s)> и C<(?x)>. К примеру,

    /(?i)yes/;  # найдет 'yes' независимо от регистра
    /yes/i;     # то же самое
    /(?x)(          # свободная версия регкспа поиска целого числа (integer)
             [+-]?  # найдет опицональный знак
             \d+    # найдет последовательность цифр
         )
    /x;

Встроенные модификаторы могут иметь два важных преимущества перед обычными
модификаторами. Встроенные модификаторы позволяют делать настраиваемый набор модификаторов для
I<каждого> шаблона в регулярном выражении. Это отлично подходит для поиска массива регулярных выражений,
которые должны иметь различные модификаторы:

    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (<>) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }

Вторым преимуществом является то, что встроенные модификаторы (за исключением C<//p>, который
изменяет весь регексп) влияют только на регексп
внутри группы, в которой содержится встроенный модификатор. Поэтому группировка
может использоваться для локализации эффектов модификаторов:

    /Answer: ((?i)yes)/;  # найдет 'Answer: yes', 'Answer: YES', etc.

Встроенные модификаторы могут также отключить любые модификаторы уже применяемые к регекспу
с помощью C<(?-i)>. Модификаторы также могут быть объединены в
одно выражение, например, C<(?s-i)> включает режим одной линии и
отключение регистра.

Встроенные модификаторы также могут быть добавлены к незахватывающим группировкам.
C<(?i-m:regexp)>— это незахватывающая группа, которая ищет C<регексп>
без учета регистра и выключает многострочный режим.

=head2 Заглядывание вперед и назад

Этот раздел рассказывает о заглядываниях вперед и назад. Сначала, немного теории.

В регулярных выражениях Perl большинство элементов регекспа "съедает" определенную
часть строки, когда они совпадают. Например регексп элемент
C<[abc}]> съедает один символ строки, когда он находит совпадение, в
смысле, что Perl перемещается на следующую позицию символа в строке
после найденного символа. Есть некоторые элементы, однако, которые не съедают
символы (предварительная позиция символа), если они совпадают. Примером, который мы 
видели до настоящего времени - бли якори. Якорь  C<^> соответствует
началу строки, но не съедает символы. Аналогичным образом,
якорь границы слова C<\b> находит там,где и знак соответствия C<\w>
 и следующий симол, но он не ест символы. 
 Якоря являются примерами I<утверждения нулевой ширины>:
нулевой ширины, потому что они не потребляют символы и 
утверждения, потому что они тестируют некоторые свойства
строки. В контексте нашей прогулки в лесу по аналогии с поиском регекспом, 
большинство элементов регексп перемещает нас по тропе, но у якоря
мы останавливаемся на мгновение и проверяем наше окружение. Если местная окружающая среда
проходит проверку, мы можем двигаться вперед. Но если местная окружающая среда
не удовлетворяет нас, мы должны отступить.

Checking the environment entails either looking ahead on the trail,
looking behind, or both.  C<^> looks behind, to see that there are no
characters before.  C<$> looks ahead, to see that there are no
characters after.  C<\b> looks both ahead and behind, to see if the
characters on either side differ in their "word-ness".

The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by C<(?=regexp)> and the lookbehind
assertion is denoted by C<< (?<=fixed-regexp) >>.  Some examples are

    $x = "I catch the housecat 'Tom-cat' with catnip";
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?<=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom-cat'
    $x =~ /(?<=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x

Note that the parentheses in C<(?=regexp)> and C<< (?<=regexp) >> are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead C<(?=regexp)> can match arbitrary regexps, but
lookbehind C<< (?<=fixed-regexp) >> only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
C<< (?<=(ab|bc)) >> is fine, but C<< (?<=(ab)*) >> is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by C<(?!regexp)> and C<< (?<!fixed-regexp) >> respectively.
They evaluate true if the regexps do I<not> match:

    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?<!\s)foo/;  # matches, there is no \s before 'foo'

The C<\C> is unsupported in lookbehind, because the already
treacherous definition of C<\C> would become even more so
when going backwards.

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using C</\s+/> alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:

    $str = "one two - --6-8";
    @toks = split / \s+              # a run of spaces
                  | (?<=\S) (?=-)    # any non-space followed by '-'
                  | (?<=-)  (?=\S)   # a '-' followed by any non-space
                  /x, $str;          # @toks = qw(one two - - - 6 - 8)


=head2 Using independent subexpressions to prevent backtracking

I<Independent subexpressions> are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by C<< (?>regexp) >>.  We can illustrate their behavior by first
considering an ordinary regexp:

    $x = "ab";
    $x =~ /a*ab/;  # matches

This obviously matches, but in the process of matching, the
subexpression C<a*> first grabbed the C<a>.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, C<a*>
eventually gave back the C<a> and matched the empty string.  Here, what
C<a*> matched was I<dependent> on what the rest of the regexp matched.

Contrast that with an independent subexpression:

    $x =~ /(?>a*)ab/;  # doesn't match!

The independent subexpression C<< (?>a*) >> doesn't care about the rest
of the regexp, so it sees an C<a> and grabs it.  Then the rest of the
regexp C<ab> cannot match.  Because C<< (?>a*) >> is independent, there
is no backtracking and the independent subexpression does not give
up its C<a>.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:

    $x = "ab";
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available

Here C<//g> and C<\G> create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.

The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:

    $x = "abc(de(fg)h";  # unbalanced parentheses
    $x =~ /\( ( [^()]+ | \([^()]*\) )+ \)/x;

The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative C<[^()]+> matching a substring with no
parentheses and the second alternative C<\([^()]*\)>  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form C<(a+|b)+>.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:

    $x =~ /\( ( (?>[^()]+) | \([^()]*\) )+ \)/x;

Here, C<< (?>[^()]+) >> breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.


=head2 Conditional expressions

A I<conditional expression> is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
C<(?(condition)yes-regexp)> and
C<(?(condition)yes-regexp|no-regexp)>.  C<(?(condition)yes-regexp)> is
like an S<C<'if () {}'>> statement in Perl.  If the C<condition> is true,
the C<yes-regexp> will be matched.  If the C<condition> is false, the
C<yes-regexp> will be skipped and Perl will move onto the next regexp
element.  The second form is like an S<C<'if () {} else {}'>> statement
in Perl.  If the C<condition> is true, the C<yes-regexp> will be
matched, otherwise the C<no-regexp> will be matched.

The C<condition> can have several forms.  The first form is simply an
integer in parentheses C<(integer)>.  It is true if the corresponding
backreference C<\integer> matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as C<< (<name>) >> or C<< ('name') >>.  The second form is a bare
zero-width assertion C<(?...)>, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (C<(R)>) or is being called from some capturing group,
referenced either by number (C<(R1)>, C<(R2)>,...) or by name
(C<(R&name)>).

The integer or name form of the C<condition> allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form C<"$x$x"> or C<"$x$y$y$x">:

    % simple_grep '^(\w+)(\w+)?(?(2)\g2\g1|\g1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu

The lookbehind C<condition> allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,

    /[ATGC]+(?(?<=AA)G|C)$/;

matches a DNA sequence such that it either ends in C<AAG>, or some
other base pair combination and C<C>.  Note that the form is
C<< (?(?<=AA)G|C) >> and not C<< (?((?<=AA))G|C) >>; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.


=head2 Defining named patterns

Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is C<< (?(DEFINE)(?<name>pattern)...) >>.  An insertion
of a named pattern is written as C<(?&name)>.

The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.

   /^ (?&osg)\ * ( (?&int)(?&dec)? | (?&dec) )
      (?: [eE](?&osg)(?&int) )?
    $
    (?(DEFINE)
      (?<osg>[-+]?)         # optional sign
      (?<int>\d++)          # integer
      (?<dec>\.(?&int))     # decimal fraction
    )/x


=head2 Recursive patterns

This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
C<(?group-ref)>, the I<pattern> within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained I<within> the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.

To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.

    /(?: (\w) (?...Here be a palindrome...) \g{-1} | \w? )/x

Adding C<\W*> at either end to eliminate what is to be ignored, we already
have the full pattern:

    my $pp = qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix;
    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
        print "'$s' is a palindrome\n" if $s =~ /$pp/;
    }

In C<(?...)> both absolute and relative backreferences may be used.
The entire pattern can be reinserted with C<(?R)> or C<(?0)>.
If you prefer to name your groups, you can use C<(?&name)> to
recurse into that group.


=head2 A bit of magic: executing Perl code in a regular expression

Normally, regexps are a part of Perl expressions.
I<Code evaluation> expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted C<(?{code})>, with I<code> a string of Perl
statements.

Be warned that this feature is considered experimental, and may be
changed without notice.

Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
C<(?(condition)...)>, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
C<$^R>.  The variable C<$^R> can then be used in code expressions later
in the regexp.  Here are some silly examples:

    $x = "abcdef";
    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn't match,
                                         # no 'Hi Mom!'

Pay careful attention to the next example:

    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?

At first glance, you'd think that it shouldn't print, because obviously
the C<ddd> isn't going to match the target string. But look at this
example:

    $x =~ /abc(?{print "Hi Mom!";})[dD]dd/; # doesn't match,
                                            # but _does_ print

Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the C<d> in a character class isn't going to change what it
matches. So why does the first not print while the second one does?

The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
C<?{}> construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.

To take a closer look at how the engine does optimizations, see the
section L<"Pragmas and debugging"> below.

More fun with C<?{}>:

    $x =~ /(?{print "Hi Mom!";})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
                                           # prints '1'

The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using C<local>, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,

    $x = "aaaa";
    $count = 0;  # initialize 'a' count
    $c = "bob";  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print "'a' count is $count, \$c variable is '$c'\n";

This prints

    'a' count is 2, $c variable is 'bob'

If we replace the S<C< (?{local $c = $c + 1;})>> with
S<C< (?{$c = $c + 1;})>>, the variable changes are I<not> undone
during backtracking, and we get

    'a' count is 4, $c variable is 'bob'

Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Òàêèì îáðàçîì

    $x = "aaaa";
    $x =~ /(a(?{print "Yow\n";}))*aa/;

produces

   Yow
   Yow
   Yow
   Yow

The result C<$^R> is automatically localized, so that it will behave
properly in the presence of backtracking.

This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:

    $lang = 'DE';  # use German
    ...
    $text = "das";
    print "matched\n"
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;

Note that the syntax here is C<(?(?{...})yes-regexp|no-regexp)>, not
C<(?((?{...}))yes-regexp|no-regexp)>.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.

If you try to use code expressions where the code text is contained within
an interpolated variable, rather than appearing literally in the pattern,
Perl may surprise you:

    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compiles ok, $bar interpolated
    /foo${pat}bar/;      # compile error!

    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok

If a regexp has a variable that interpolates a code expression, Perl
treats the regexp as an error. If the code expression is precompiled into
a variable, however, interpolating is ok. The question is, why is this an
error?

The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:

    $regexp = <>;       # read user-supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp

If the C<$regexp> variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for S<C<system('rm -rf *');>> to erase your files.  In this
sense, the combination of interpolation and code expressions I<taints>
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking S<C<use re 'eval'>>:

    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo${pat}bar/;      # compiles ok

Another form of code expression is the I<pattern code expression>.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is

    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'


This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string C<1101010010001...> has a
Fibonacci spacing 0,1,1,2,3,5,...  of the C<1>'s:

    $x = "1101010010001000001";
    $z0 = ''; $z1 = '0';   # initial conditions
    print "It is a Fibonacci sequence\n"
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
		       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf "Largest sequence matched was %d\n", length($z1)-length($z0);

Remember that C<$^N> is set to whatever was matched by the last
completed capture group. This prints

    It is a Fibonacci sequence
    Largest sequence matched was 5

Ha! Try that with your garden variety regexp package...

Note that the variables C<$z0> and C<$z1> are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the whole code block is parsed as perl code at the
same time as perl is compiling the code containing the literal regexp
pattern.

The regexp without the C<//x> modifier is

    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/

which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.


=head2 Backtracking control verbs

Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to L<perlre/"Special Backtracking Control Verbs"> for a
detailed description.

Below is just one example, illustrating the control verb C<(*FAIL)>,
which may be abbreviated as C<(*F)>. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.

   %count = ();
   "supercalifragilisticexpialidocious" =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
   printf "%3d '%s'\n", $count{$_}, $_ for (sort keys %count);

The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like C<$count{'a'}++;> is executed, incrementing
the letter's counter. Then C<(*FAIL)> does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like

   $count{lc($_)}++ for split('', "supercalifragilisticexpialidocious");
   printf "%3d '%s'\n", $count2{$_}, $_ for ( qw{ a e i o u } );

is considerably slower.)


=head2 Pragmas and debugging

Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, S<C<use re 'eval';>>, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are

    use re 'taint';
    $tainted = <>;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted

The C<taint> pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use C<taint> when you are not extracting safe bits, but are
performing some other processing.  Both C<taint> and C<eval> pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.

    use re '/m';  # or any other flags
    $multiline_string =~ /^foo/; # /m is implied

The C<re '/flags'> pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
L<re/"'E<sol>flags' mode"> for more
detail.

    use re 'debug';
    /^(.*)$/s;       # output debugging info

    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color

The global C<debug> and C<debugcolor> pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  C<debugcolor> is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:

    % perl -e 'use re "debug"; "abc" =~ /a*b+c/;'
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'

If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part

    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)

describes the compilation stage.  C<STAR(4)> means that there is a
starred object, in this case C<'a'>, and if it matches, goto line 4,
i.e., C<PLUS(7)>.  The middle lines describe some heuristics and
optimizations performed before a match:

    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0

Then the match is executed and the remaining lines describe the
process:

    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'

Each step is of the form S<C<< n <x> <y> >>>, with C<< <x> >> the
part of the string matched and C<< <y> >> the part not yet
matched.  The S<C<< |  1:  STAR >>> says that Perl is at line number 1
in the compilation list above.  See
L<perldebguts/"Debugging Regular Expressions"> for much more detail.

Альтернативным методом отладки регулярных выражений является включение включение C<print>
в регексп. Здесь предоставляется подробный отчет
об обратных ссылках в случае оператора C<или>:

    use utf8;
    use Encode::Locale;

    if (-t) 
    {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
    "that this" =~ m@(?{print "Начали в позиции ", pos, "\n";})
                     t(?{print "t1\n";})
                     h(?{print "h1\n";})
                     i(?{print "i1\n";})
                     s(?{print "s1\n";})
                         |
                     t(?{print "t2\n";})
                     h(?{print "h2\n";})
                     a(?{print "a2\n";})
                     t(?{print "t2\n";})
                     (?{print "Закончили в позиции ", pos, "\n";})
                    @x;

напечатает

    Начали в позиции 0
    t1
    h1
    t2
    h2
    a2
    t2
    Закончили в позиции 4

=head1 ОШИБКИ

Выражения с кодом, условные выражения и независимые выражения 
являются I<экспериментальными>. Не используйте их в рабочем коде. Пока.

=head1 СМОТРИТЕ ТАКЖЕ

Это всего лишь учебное пособие. Для полной истории регулярных выражений 
смотри справку в L<perlre>.

Для получения дополнительной информации об операторах поиска C<m//>  и замены C<s///>
см L<perlop/"Regexp Quote-Like Operators">. Для
информация об операции C<split> см  L<perlfunc/split>.

Для превосходного всестороннего ресурса по уходу и кормлению
регулярных выражений, см. книгу I<Mastering Regular Expressions> by
Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).

=head1 АВТОР И АВТОРСКОЕ ПРАВО

Copyright (c) 2000 Mark Kvale
Все права защищены.

Этот документ может распространяться на тех же условиях, что и Perl.

=head2 Благодарности

Вдохновленный примером stop codon DNA  пришедшим из ZIP
примеров кода в главе 7 книги I<Mastering Regular Expressions>.

Автор хотел бы поблагодарить Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, и Joe Smith за все их полезные
комментарии.


=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mishin@cpan.org> >>
 
=back


